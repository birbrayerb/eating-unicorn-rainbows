<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ü¶Ñ Eating Unicorn Rainbows üåà</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html, body { width:100%; height:100%; overflow:hidden; background:#1a0a2e; touch-action:none; user-select:none; -webkit-user-select:none; }
canvas { display:block; width:100%; height:100%; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// ============================================================
// ü¶Ñ EATING UNICORN RAINBOWS ‚Äî Vertical Racer Edition üåà
// ============================================================

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

// --- Audio ---
let audioCtx;
function initAudio() { if (audioCtx) return; audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playChime(freq, dur=0.15, vol=0.12, type='sine') {
  if (!audioCtx) return;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
}

function playEatSound(pts) {
  const base = pts >= 100 ? 880 : pts >= 50 ? 660 : 523;
  playChime(base, 0.2, 0.1);
  setTimeout(() => playChime(base * 1.25, 0.15, 0.08), 50);
  if (pts >= 50) setTimeout(() => playChime(base * 1.5, 0.12, 0.06), 100);
}

function playWinFanfare() {
  const notes = [523,659,784,1047,784,1047,1319,1047,1319,1568];
  notes.forEach((f,i) => setTimeout(() => playChime(f, 0.4, 0.12, i%2?'sine':'triangle'), i*150));
}

let melodyInterval;
function startMelody() {
  if (melodyInterval) return;
  const scale = [262,294,330,349,392,440,494,523,494,440,392,349,330,294];
  let idx = 0;
  melodyInterval = setInterval(() => {
    if (gameState !== 'playing') return;
    playChime(scale[idx % scale.length], 0.3, 0.03, 'triangle');
    idx++;
  }, 600);
}
function stopMelody() { clearInterval(melodyInterval); melodyInterval = null; }

// --- Seeded Random for track layout ---
function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}

// --- Track Generation ---
const TRACK_LENGTH = 10000;
const TRACK_SEED = 42069;
let trackRainbows = []; // {y, x, type} - y is distance along track (0=start, TRACK_LENGTH=end)

function generateTrack() {
  const rng = seededRandom(TRACK_SEED);
  trackRainbows = [];
  // Place rainbows along the track
  // Small rainbows: frequent, big: occasional, gold: rare
  for (let y = 200; y < TRACK_LENGTH - 200; y += 60) {
    const r = rng();
    if (r < 0.45) {
      // small rainbow (10 pts) ‚Äî most common
      trackRainbows.push({ y, x: rng() * 0.8 + 0.1, type: 'small', points: 10 });
    } else if (r < 0.58) {
      // big rainbow (50 pts)
      trackRainbows.push({ y, x: rng() * 0.8 + 0.1, type: 'big', points: 50 });
    } else if (r < 0.62) {
      // gold rainbow (100 pts)
      trackRainbows.push({ y, x: rng() * 0.8 + 0.1, type: 'gold', points: 100 });
    }
    // else: empty space
  }
  // Also generate some star decorations (non-collectible background)
  trackStars = [];
  for (let y = 0; y < TRACK_LENGTH; y += 30) {
    if (rng() < 0.3) {
      trackStars.push({ y, x: rng(), size: rng()*2+1, twinkleOffset: rng()*Math.PI*2 });
    }
  }
}

let trackStars = [];

// --- Leaderboard ---
let leaderboard = [];
let showingNameEntry = false;
let pendingScore = 0;
let nameInput = '';

async function fetchLeaderboard() {
  try {
    const r = await fetch('/api/scores');
    const d = await r.json();
    if (d.scores) leaderboard = d.scores;
  } catch(e) { console.log('Leaderboard offline'); }
}

async function submitScore(name, sc) {
  try {
    const r = await fetch('/api/scores', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, score: sc })
    });
    const d = await r.json();
    if (d.scores) leaderboard = d.scores;
  } catch(e) { console.log('Could not submit score'); }
}

fetchLeaderboard();

// --- Game State ---
let gameState = 'title'; // title, playing, win
let score = 0;
let distance = 0; // how far along the track (0 to TRACK_LENGTH)
let titleTime = 0;
let winTime = 0;
let collectedSet = new Set(); // indices of collected rainbows

// Speed: units per second. TRACK_LENGTH=10000, want ~90 seconds ‚Üí ~111 units/sec
const BASE_SPEED = 110;

// --- Unicorn ---
const unicorn = {
  x: 0.5, // 0-1 horizontal position (fraction of screen width)
  trail: [],
  sparkle: 0,
  blinkTimer: 3,
};

const UNICORN_MOVE_SPEED = 1.8; // fraction of screen per second
let moveDir = 0; // -1, 0, 1

// --- Particles & effects ---
let particles = [];
let fireworks = [];
let bgClouds = [];

function initBGClouds() {
  bgClouds = [];
  for (let i = 0; i < 8; i++) {
    bgClouds.push({ x: Math.random(), y: Math.random()*H, w: Math.random()*150+80, alpha: Math.random()*0.15+0.05 });
  }
}

function spawnParticles(x, y, color, count=8, spread=3) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random()*Math.PI*2;
    const speed = Math.random()*spread+1;
    particles.push({
      x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
      life: 1, decay: 0.015+Math.random()*0.02,
      color, size: Math.random()*5+2,
      type: Math.random()<0.3 ? 'star' : 'circle',
    });
  }
}

function spawnFirework(x, y) {
  const colors = ['#ff6b9d','#ffd700','#4dc9ff','#c44dff','#4dff88','#ff9e4d','#fff'];
  const c = colors[Math.floor(Math.random()*colors.length)];
  for (let i = 0; i < 30; i++) {
    const angle = Math.random()*Math.PI*2;
    const speed = Math.random()*6+2;
    fireworks.push({
      x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed-2,
      life: 1, decay: 0.01+Math.random()*0.015, color: c, size: Math.random()*4+2,
    });
  }
}

// --- Input ---
let keys = {};
let touchTargetX = null; // finger X position ‚Äî unicorn follows horizontally
let touchActive = false;

document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  initAudio();
  if (showingNameEntry) {
    if (e.key === 'Backspace') { nameInput = nameInput.slice(0,-1); e.preventDefault(); return; }
    if (e.key === 'Enter' && nameInput.length > 0) { finishNameEntry(); return; }
    if (/^[a-zA-Z0-9 ]$/.test(e.key) && nameInput.length < 12) { nameInput += e.key.toUpperCase(); }
  }
});
document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('pointerdown', e => {
  initAudio();
  if (gameState === 'title') { startGame(); return; }
  if (gameState === 'win') {
    if (showingNameEntry) { handleNameClick(e.clientX, e.clientY); return; }
    if (winTime > 2) { resetToTitle(); return; }
    return;
  }
  // Playing: unicorn follows finger horizontally
  touchTargetX = e.clientX;
  touchActive = true;
});
canvas.addEventListener('pointermove', e => {
  if (gameState !== 'playing') return;
  if (touchActive) touchTargetX = e.clientX;
});
canvas.addEventListener('pointerup', e => { touchActive = false; });
canvas.addEventListener('pointercancel', e => { touchActive = false; });

// --- Name Entry ---
function handleNameClick(cx, cy) {
  const kb = window._nameKB;
  if (!kb) return;
  const { letters, btnSize, btnPad, rowLen, kbStartX, kbStartY, ctrlY, ctrlBtnW } = kb;
  for (let i = 0; i < letters.length; i++) {
    const row = Math.floor(i / rowLen);
    const col = i % rowLen;
    const bx = kbStartX + col * (btnSize + btnPad);
    const by = kbStartY + row * (btnSize + btnPad);
    if (cx >= bx && cx <= bx+btnSize && cy >= by && cy <= by+btnSize) {
      if (nameInput.length < 12) { nameInput += letters[i]; playChime(400+i*20, 0.1, 0.08); }
      return;
    }
  }
  if (cx >= W/2-ctrlBtnW-10 && cx <= W/2-10 && cy >= ctrlY && cy <= ctrlY+btnSize+4) {
    nameInput = nameInput.slice(0,-1); playChime(300, 0.1, 0.06); return;
  }
  if (cx >= W/2+10 && cx <= W/2+10+ctrlBtnW && cy >= ctrlY && cy <= ctrlY+btnSize+4) {
    if (nameInput.length > 0) finishNameEntry();
    return;
  }
}

function finishNameEntry() {
  submitScore(nameInput, pendingScore);
  showingNameEntry = false;
  window._nameSubmitted = true;
  winTime = 0;
  playChime(800, 0.3, 0.1);
}

// --- Game Flow ---
function startGame() {
  gameState = 'playing';
  score = 0; distance = 0;
  unicorn.x = 0.5; unicorn.trail = []; unicorn.sparkle = 0;
  collectedSet = new Set();
  particles = []; fireworks = [];
  generateTrack();
  startMelody();
}

function resetToTitle() {
  gameState = 'title'; titleTime = 0;
  stopMelody();
  particles = []; fireworks = [];
  fetchLeaderboard();
}

// --- Update ---
let lastTime = 0;
function update(dt) {
  if (gameState === 'title') { titleTime += dt; return; }
  if (gameState === 'win') {
    winTime += dt;
    if (Math.random() < 0.15) spawnFirework(Math.random()*W, Math.random()*H*0.6);
    fireworks.forEach(f => { f.x += f.vx; f.y += f.vy; f.vy += 0.05; f.life -= f.decay; });
    fireworks = fireworks.filter(f => f.life > 0);
    particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= p.decay; });
    particles = particles.filter(p => p.life > 0);
    return;
  }

  // --- Playing ---
  // Move forward
  distance += BASE_SPEED * dt;

  // Check win
  if (distance >= TRACK_LENGTH) {
    distance = TRACK_LENGTH;
    gameState = 'win'; winTime = 0;
    playWinFanfare();
    for (let i=0;i<10;i++) spawnFirework(Math.random()*W, Math.random()*H*0.5);
    // Check if top 10
    const minTop10 = leaderboard.length >= 10 ? leaderboard[leaderboard.length-1].score : 0;
    if (score > minTop10 || leaderboard.length < 10) {
      showingNameEntry = true;
      pendingScore = score;
      nameInput = '';
      window._nameSubmitted = false;
    } else {
      showingNameEntry = false;
      window._nameSubmitted = false;
    }
    return;
  }

  // Horizontal movement
  moveDir = 0;
  if (keys['arrowleft'] || keys['a']) moveDir = -1;
  if (keys['arrowright'] || keys['d']) moveDir = 1;

  // Touch: smoothly move toward finger X position
  if (touchActive && touchTargetX !== null) {
    const dx = touchTargetX - unicorn.x;
    if (Math.abs(dx) > 2) {
      unicorn.x += dx * 6 * dt; // smooth follow
    }
  }
  // Keyboard always works too
  unicorn.x += moveDir * UNICORN_MOVE_SPEED * dt;
  unicorn.x = Math.max(0.05, Math.min(0.95, unicorn.x));

  // Trail
  if (Math.random() < 0.5) {
    unicorn.trail.push({ x: unicorn.x * W, y: H * 0.72, life: 1 });
    if (unicorn.trail.length > 25) unicorn.trail.shift();
  }
  unicorn.trail.forEach(t => t.life -= 0.03);
  unicorn.trail = unicorn.trail.filter(t => t.life > 0);

  // Blink
  unicorn.blinkTimer -= dt;
  if (unicorn.blinkTimer <= 0) unicorn.blinkTimer = 2 + Math.random()*3;

  // Rainbow collision
  const ux = unicorn.x; // 0-1
  const collectRadius = 0.06; // fraction of screen width
  const collectDistY = 150; // how far ahead/behind in track units to check

  trackRainbows.forEach((rb, i) => {
    if (collectedSet.has(i)) return;
    const dy = rb.y - distance;
    // Only check if near the unicorn vertically (on screen)
    if (Math.abs(dy - H*0.25) > collectDistY) return; // unicorn is at ~75% from top visually, map that
    // Convert track position to screen Y
    const screenY = H - (rb.y - distance) * (H / (TRACK_LENGTH * 0.015));
    // Actually, simpler: the visible window is distance to distance + viewRange
    const viewRange = 600; // track units visible on screen
    const relY = (rb.y - distance) / viewRange; // 0 = at unicorn level, 1 = top of screen
    if (relY < -0.1 || relY > 1.1) return;

    const screenRbY = H * (1 - relY * 0.85 - 0.08);
    const unicornScreenY = H * 0.72;
    const screenRbX = rb.x * W;
    const unicornScreenX = unicorn.x * W;

    const dx = screenRbX - unicornScreenX;
    const dyScreen = screenRbY - unicornScreenY;
    const dist = Math.sqrt(dx*dx + dyScreen*dyScreen);
    const hitRadius = rb.type === 'big' ? 45 : rb.type === 'gold' ? 40 : 35;

    if (dist < hitRadius) {
      collectedSet.add(i);
      score += rb.points;
      unicorn.sparkle = 1;
      playEatSound(rb.points);
      const color = rb.type === 'gold' ? '#ffd700' : rb.type === 'big' ? '#ff6b9d' : '#4dc9ff';
      spawnParticles(screenRbX, screenRbY, color, rb.type === 'gold' ? 20 : 10, rb.type === 'gold' ? 5 : 3);
    }
  });

  // Particles
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.03; p.life -= p.decay; });
  particles = particles.filter(p => p.life > 0);

  // Sparkle decay
  unicorn.sparkle *= 0.95;

  // Clouds scroll
  bgClouds.forEach(c => {
    c.y += BASE_SPEED * dt * 0.3;
    if (c.y > H + 100) { c.y = -100; c.x = Math.random(); }
  });
}

// --- Draw Helpers ---
function drawStar(cx, cy, r, points=5, color='#ffd700') {
  ctx.beginPath();
  for (let i = 0; i < points*2; i++) {
    const a = (i * Math.PI / points) - Math.PI/2;
    const rad = i%2===0 ? r : r*0.4;
    if(i===0) ctx.moveTo(cx+Math.cos(a)*rad, cy+Math.sin(a)*rad);
    else ctx.lineTo(cx+Math.cos(a)*rad, cy+Math.sin(a)*rad);
  }
  ctx.closePath(); ctx.fillStyle = color; ctx.fill();
}

function drawCloud(cx, cy, w, alpha) {
  ctx.globalAlpha = alpha;
  ctx.fillStyle = '#fff';
  const h = w*0.4;
  ctx.beginPath(); ctx.ellipse(cx, cy, w*0.5, h*0.4, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx-w*0.2, cy-h*0.15, w*0.3, h*0.35, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx+w*0.15, cy-h*0.2, w*0.25, h*0.3, 0, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;
}

// --- Draw Unicorn ---
function drawUnicorn(x, y, sparkle) {
  ctx.save();
  ctx.translate(x, y);
  const sc = 1 + sparkle*0.1;
  ctx.scale(sc, sc);
  // Face upward (toward top of screen)

  // Glow
  if (sparkle > 0.1) {
    const grad = ctx.createRadialGradient(0, 0, 10, 0, 0, 50);
    grad.addColorStop(0, `rgba(255,107,157,${sparkle*0.4})`);
    grad.addColorStop(1, 'rgba(255,107,157,0)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI*2); ctx.fill();
  }

  // Body
  ctx.fillStyle = '#fff'; ctx.strokeStyle = '#e8d5f0'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.ellipse(0, 8, 20, 16, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();

  // Head (above body, facing up)
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.ellipse(0, -12, 14, 12, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();

  // Horn (pointing up)
  ctx.fillStyle = '#ffd700';
  ctx.beginPath(); ctx.moveTo(0, -32); ctx.lineTo(-5, -18); ctx.lineTo(5, -18); ctx.closePath(); ctx.fill();
  ctx.strokeStyle = '#ffec80'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(-2, -28); ctx.lineTo(2, -25); ctx.moveTo(-1, -23); ctx.lineTo(3, -21); ctx.stroke();

  // Ears
  ctx.fillStyle = '#ffe0f0';
  ctx.beginPath(); ctx.moveTo(-8, -18); ctx.lineTo(-12, -28); ctx.lineTo(-4, -19); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(8, -18); ctx.lineTo(12, -28); ctx.lineTo(4, -19); ctx.closePath(); ctx.fill();

  // Eyes
  const blinking = unicorn.blinkTimer < 0.15;
  if (blinking) {
    ctx.strokeStyle = '#2d1b4e'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-7, -13); ctx.lineTo(-3, -13); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(3, -13); ctx.lineTo(7, -13); ctx.stroke();
  } else {
    ctx.fillStyle = '#2d1b4e';
    ctx.beginPath(); ctx.arc(-5, -13, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(5, -13, 3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(-4, -14, 1.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(6, -14, 1.2, 0, Math.PI*2); ctx.fill();
  }

  // Blush
  ctx.fillStyle = 'rgba(255,150,180,0.4)';
  ctx.beginPath(); ctx.ellipse(-9, -8, 4, 2.5, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(9, -8, 4, 2.5, 0, 0, Math.PI*2); ctx.fill();

  // Smile
  ctx.strokeStyle = '#c77dba'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(0, -7, 5, 0.3, Math.PI-0.3); ctx.stroke();

  // Mane (rainbow, flowing to the sides)
  const maneColors = ['#ff6b9d','#ff9e4d','#ffd700','#4dff88','#4dc9ff','#c44dff'];
  maneColors.forEach((c, i) => {
    ctx.fillStyle = c; ctx.globalAlpha = 0.8;
    const mx = -12 + i*1.5 + Math.sin(Date.now()/200 + i)*2;
    const my = -5 + i*3;
    ctx.beginPath(); ctx.ellipse(mx, my, 5, 3.5, -0.3+i*0.15, 0, Math.PI*2); ctx.fill();
    // Mirror right side
    const mx2 = 12 - i*1.5 + Math.sin(Date.now()/200 + i + 3)*2;
    ctx.beginPath(); ctx.ellipse(mx2, my, 5, 3.5, 0.3-i*0.15, 0, Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Tail (below, flowing down ‚Äî rainbow)
  maneColors.forEach((c, i) => {
    ctx.strokeStyle = c; ctx.lineWidth = 3; ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.moveTo(Math.sin(i)*3, 22);
    ctx.quadraticCurveTo(
      Math.sin(Date.now()/250+i)*8, 28+i*3,
      Math.sin(Date.now()/300+i*0.7)*10, 35+i*4
    );
    ctx.stroke();
  });
  ctx.globalAlpha = 1;

  // Legs (running animation)
  ctx.strokeStyle = '#e8d5f0'; ctx.lineWidth = 4; ctx.lineCap = 'round';
  const legBob = Math.sin(Date.now()/120)*4;
  [[-9,20,legBob],[9,20,-legBob],[-5,20,-legBob],[5,20,legBob]].forEach(([lx,ly,bob]) => {
    ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx+bob*0.3, ly+10); ctx.stroke();
    ctx.fillStyle = '#ddc0f0';
    ctx.beginPath(); ctx.arc(lx+bob*0.3, ly+11, 3, 0, Math.PI*2); ctx.fill();
  });

  ctx.restore();
}

// --- Draw Rainbow Collectible ---
function drawRainbow(x, y, type) {
  ctx.save();
  ctx.translate(x, y);

  const r = type === 'big' ? 28 : type === 'gold' ? 24 : 18;

  // Glow
  const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r*2);
  grad.addColorStop(0, 'rgba(255,200,255,0.25)');
  grad.addColorStop(1, 'rgba(255,200,255,0)');
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(0, -r*0.2, r*2, 0, Math.PI*2); ctx.fill();

  if (type === 'gold') {
    const goldColors = ['#fff8dc','#ffd700','#ffb800','#ff9500','#ffd700','#fff8dc'];
    ctx.lineCap = 'round';
    goldColors.forEach((c, i) => {
      const arcR = r - i*2.5; if (arcR <= 0) return;
      ctx.strokeStyle = c; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(0, r*0.3, arcR, Math.PI, 0); ctx.stroke();
    });
    // Sparkles
    for (let i = 0; i < 5; i++) {
      const a = Math.PI + (i/4)*Math.PI;
      const sr = r - 6;
      ctx.globalAlpha = 0.4 + Math.sin(Date.now()/200+i*1.5)*0.4;
      drawStar(Math.cos(a)*sr, r*0.3+Math.sin(a)*sr, 4, 4, '#fff');
    }
    ctx.globalAlpha = 1;
    // Points label
    ctx.fillStyle = '#ffd700'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('100', 0, r*0.3 + r + 12);
  } else {
    const rainbowColors = ['#ff0000','#ff8800','#ffdd00','#00cc44','#0088ff','#8844ff','#cc44cc'];
    ctx.lineCap = 'round';
    const lineW = type === 'big' ? 3 : 2;
    rainbowColors.forEach((c, i) => {
      const arcR = r - i*(type==='big'?2.8:2); if (arcR <= 2) return;
      ctx.strokeStyle = c; ctx.lineWidth = lineW;
      ctx.beginPath(); ctx.arc(0, r*0.3, arcR, Math.PI, 0); ctx.stroke();
    });
    // Clouds at feet
    ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.7;
    ctx.beginPath(); ctx.ellipse(-r+2, r*0.3, 5, 3, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r-2, r*0.3, 5, 3, 0, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    // Points label
    ctx.fillStyle = type === 'big' ? '#ff6b9d' : '#4dc9ff';
    ctx.font = `bold ${type==='big'?12:10}px sans-serif`; ctx.textAlign = 'center';
    ctx.fillText(type === 'big' ? '50' : '10', 0, r*0.3 + r + 10);
  }

  ctx.restore();
}

// --- Draw Big Finish Rainbow ---
function drawFinishRainbow(y) {
  ctx.save();
  ctx.translate(W/2, y);
  const r = W * 0.4;
  const rainbowColors = ['#ff0000','#ff8800','#ffdd00','#00cc44','#0088ff','#8844ff','#cc44cc'];
  ctx.lineCap = 'round';
  rainbowColors.forEach((c, i) => {
    const arcR = r - i*8; if (arcR <= 0) return;
    ctx.strokeStyle = c; ctx.lineWidth = 8;
    ctx.beginPath(); ctx.arc(0, 0, arcR, Math.PI, 0); ctx.stroke();
  });
  // Sparkles
  for (let i = 0; i < 12; i++) {
    const a = Math.PI + (i/11)*Math.PI;
    ctx.globalAlpha = 0.5 + Math.sin(Date.now()/200+i)*0.4;
    drawStar(Math.cos(a)*(r+15), Math.sin(a)*(r+15), 6, 5, '#ffd700');
  }
  ctx.globalAlpha = 1;
  // Label
  ctx.fillStyle = '#ffd700'; ctx.font = `bold ${Math.min(24,W*0.05)}px sans-serif`; ctx.textAlign = 'center';
  ctx.fillText('üåà FINISH! üåà', 0, -r - 15);
  ctx.restore();
}

// --- Draw Background ---
function drawPlayBackground() {
  // Sky gradient
  const progress = distance / TRACK_LENGTH;
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  // Sky gets brighter as you progress
  const r1 = Math.floor(20 + progress*50);
  const g1 = Math.floor(8 + progress*30);
  const b1 = Math.floor(50 + progress*60);
  const r2 = Math.floor(40 + progress*80);
  const g2 = Math.floor(15 + progress*50);
  const b2 = Math.floor(80 + progress*70);
  grad.addColorStop(0, `rgb(${r1},${g1},${b1})`);
  grad.addColorStop(1, `rgb(${r2},${g2},${b2})`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Scrolling stars
  const viewRange = 600;
  trackStars.forEach(s => {
    const relY = (s.y - distance) / viewRange;
    if (relY < -0.1 || relY > 1.2) return;
    const sy = H * (1 - relY * 0.85 - 0.08);
    const sx = s.x * W;
    const alpha = 0.3 + Math.sin(Date.now()*0.003 + s.twinkleOffset)*0.3;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#fff';
    if (s.size > 1.5) drawStar(sx, sy, s.size, 4, '#fff');
    else { ctx.beginPath(); ctx.arc(sx, sy, s.size, 0, Math.PI*2); ctx.fill(); }
  });
  ctx.globalAlpha = 1;

  // Clouds
  bgClouds.forEach(c => drawCloud(c.x * W, c.y, c.w, c.alpha));

  // Rainbow road lane (subtle center lane)
  const laneW = W * 0.6;
  const laneX = (W - laneW) / 2;
  const laneGrad = ctx.createLinearGradient(laneX, 0, laneX + laneW, 0);
  laneGrad.addColorStop(0, 'rgba(255,107,157,0)');
  laneGrad.addColorStop(0.1, 'rgba(255,107,157,0.04)');
  laneGrad.addColorStop(0.3, 'rgba(255,158,77,0.04)');
  laneGrad.addColorStop(0.5, 'rgba(255,215,0,0.05)');
  laneGrad.addColorStop(0.7, 'rgba(77,255,136,0.04)');
  laneGrad.addColorStop(0.9, 'rgba(77,201,255,0.04)');
  laneGrad.addColorStop(1, 'rgba(196,77,255,0)');
  ctx.fillStyle = laneGrad;
  ctx.fillRect(laneX, 0, laneW, H);

  // Lane edge lines (subtle)
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 20]);
  ctx.beginPath(); ctx.moveTo(laneX, 0); ctx.lineTo(laneX, H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(laneX+laneW, 0); ctx.lineTo(laneX+laneW, H); ctx.stroke();
  ctx.setLineDash([]);
}

// --- Draw HUD ---
function drawHUD() {
  const progress = distance / TRACK_LENGTH;

  // Score (top left)
  ctx.fillStyle = '#ffd700';
  ctx.font = `bold ${Math.min(22, W*0.04)}px sans-serif`;
  ctx.textAlign = 'left';
  ctx.fillText(`‚ú® ${score}`, 15, 32);

  // Progress bar (right side, vertical)
  const barH = H * 0.6;
  const barW = 18;
  const barX = W - 35;
  const barY = (H - barH) / 2;

  // Label
  ctx.save();
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.min(11, W*0.022)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.translate(barX + barW/2, barY - 15);
  ctx.fillText('üåà', 0, 0);
  ctx.restore();

  // Bar background
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.roundRect(barX, barY, barW, barH, barW/2); ctx.fill();

  // Bar fill (from bottom up, rainbow gradient)
  if (progress > 0) {
    const fillH = barH * progress;
    const fGrad = ctx.createLinearGradient(0, barY+barH, 0, barY+barH-fillH);
    fGrad.addColorStop(0, '#ff6b9d');
    fGrad.addColorStop(0.2, '#ff9e4d');
    fGrad.addColorStop(0.4, '#ffd700');
    fGrad.addColorStop(0.6, '#4dff88');
    fGrad.addColorStop(0.8, '#4dc9ff');
    fGrad.addColorStop(1, '#c44dff');
    ctx.fillStyle = fGrad;
    ctx.beginPath();
    ctx.roundRect(barX+2, barY+barH-fillH, barW-4, fillH, (barW-4)/2);
    ctx.fill();
  }

  // Unicorn indicator on progress bar
  const indicatorY = barY + barH - barH * progress;
  ctx.font = '14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('ü¶Ñ', barX + barW/2 - 16, indicatorY + 5);

  // Finish rainbow at top of bar
  ctx.fillText('üåà', barX + barW/2, barY + barH + 18);

  // Percentage
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.min(12, W*0.024)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(`${Math.floor(progress*100)}%`, barX + barW/2, barY + barH + 32);

  // Touch indicators (subtle)
  if (gameState === 'playing') {
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.min(30, W*0.06)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText('‚óÄ', W*0.12, H*0.5);
    ctx.fillText('‚ñ∂', W*0.88, H*0.5);
    ctx.globalAlpha = 1;
  }
}

// --- Draw Title ---
function drawTitle() {
  // Background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a0a2e'); grad.addColorStop(1, '#2d1050');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);

  const t = titleTime;
  ctx.textAlign = 'center';

  // Unicorn emoji
  ctx.font = `${50+Math.sin(t*2)*4}px sans-serif`;
  ctx.fillText('ü¶Ñ', W/2, H*0.11);

  // Title rainbow letters
  const title = 'Eating Unicorn Rainbows';
  const titleSize = Math.min(32, W*0.055);
  ctx.font = `bold ${titleSize}px sans-serif`;
  const colors = ['#ff6b9d','#ff9e4d','#ffd700','#4dff88','#4dc9ff','#c44dff'];
  const metrics = ctx.measureText(title);
  const startX = W/2 - metrics.width/2;
  for (let i = 0; i < title.length; i++) {
    ctx.fillStyle = colors[Math.floor((i+t*3)%colors.length)];
    const charW = ctx.measureText(title[i]).width;
    const yOff = Math.sin(t*3+i*0.3)*4;
    ctx.fillText(title[i], startX+ctx.measureText(title.substring(0,i)).width+charW/2, H*0.20+yOff);
  }

  // Subtitle
  ctx.fillStyle = '#c9a0ff';
  ctx.font = `${Math.min(16, W*0.03)}px sans-serif`;
  ctx.fillText('üèÅ Vertical Rainbow Race! üèÅ', W/2, H*0.26);

  // Instructions
  const instructions = [
    { icon: 'ü¶Ñ', text: 'Race upward to the Big Rainbow!', color: '#ff6b9d' },
    { icon: 'üëÜ', text: 'Drag your finger to move!', color: '#4dc9ff' },
    { icon: 'üåà', text: 'Collect rainbows for points!', color: '#ffd700' },
    { icon: '‚ú®', text: 'Gold = 100, Big = 50, Small = 10', color: '#ffec80' },
    { icon: 'üèÜ', text: 'Same track for everyone ‚Äî compete!', color: '#4dff88' },
  ];

  const instrSize = Math.min(16, W*0.032);
  const instrStartY = H*0.32;
  const instrSpacing = Math.min(34, H*0.05);

  instructions.forEach((inst, i) => {
    const fadeStart = 0.5 + i*0.5;
    const alpha = Math.min(1, Math.max(0, (t-fadeStart)*2));
    const bob = Math.sin(t*2+i*0.8)*3;
    ctx.globalAlpha = alpha;
    ctx.font = `${Math.min(22,W*0.04)}px sans-serif`;
    ctx.fillText(inst.icon, W/2 - Math.min(150,W*0.3), instrStartY+i*instrSpacing+bob);
    ctx.font = `bold ${instrSize}px sans-serif`;
    ctx.fillStyle = inst.color;
    ctx.fillText(inst.text, W/2+10, instrStartY+i*instrSpacing+bob);
  });
  ctx.globalAlpha = 1;

  // Leaderboard
  const lbY = instrStartY + instructions.length*instrSpacing + 20;
  if (leaderboard.length > 0) {
    ctx.fillStyle = '#ffd700';
    ctx.font = `bold ${Math.min(18,W*0.035)}px sans-serif`;
    ctx.fillText('üèÜ Top 10 Scores üèÜ', W/2, lbY);
    const lbSize = Math.min(13, W*0.026);
    ctx.font = `${lbSize}px sans-serif`;
    leaderboard.slice(0,10).forEach((s,i) => {
      const medal = i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':'‚≠ê';
      ctx.fillStyle = i<3?'#ffd700':'#ccc';
      ctx.fillText(`${medal} ${s.name} ‚Äî ${s.score}pts`, W/2, lbY+18+i*(lbSize+5));
    });
  }

  // Tap to play
  const pulse = 0.7+Math.sin(t*3)*0.3;
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#ffd700';
  ctx.font = `bold ${Math.min(28,W*0.05)}px sans-serif`;
  ctx.fillText('üåü Tap to Race! üåü', W/2, H*0.92);
  ctx.globalAlpha = 1;
}

// --- Draw Win Screen ---
function drawWinScreen() {
  // Background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a0a2e'); grad.addColorStop(1, '#2d1050');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);

  // Fireworks
  fireworks.forEach(f => {
    ctx.globalAlpha = f.life; ctx.fillStyle = f.color;
    ctx.beginPath(); ctx.arc(f.x, f.y, f.size, 0, Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
    if (p.type==='star') drawStar(p.x,p.y,p.size,4,p.color);
    else { ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); }
  });
  ctx.globalAlpha = 1;

  ctx.textAlign = 'center';

  if (showingNameEntry) {
    // Name entry
    ctx.fillStyle = '#ffd700';
    ctx.font = `bold ${Math.min(28,W*0.05)}px sans-serif`;
    ctx.fillText('‚≠ê TOP 10 SCORE! ‚≠ê', W/2, H*0.10);

    ctx.fillStyle = '#fff';
    ctx.font = `${Math.min(22,W*0.04)}px sans-serif`;
    ctx.fillText(`${pendingScore} points!`, W/2, H*0.17);

    ctx.fillStyle = '#ff6b9d';
    ctx.font = `bold ${Math.min(22,W*0.04)}px sans-serif`;
    ctx.fillText("What's your name? ü¶Ñ", W/2, H*0.24);

    // Input box
    const boxW = Math.min(280,W*0.7), boxH = 50;
    const boxX = (W-boxW)/2, boxY = H*0.27;
    ctx.shadowColor = '#ff6b9d'; ctx.shadowBlur = 15;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.beginPath(); ctx.roundRect(boxX, boxY, boxW, boxH, 15); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = nameInput ? '#2d1b4e' : '#bbb';
    ctx.font = `bold ${Math.min(26,W*0.045)}px sans-serif`;
    const cursor = Math.sin(winTime*5)>0 ? '|' : '';
    ctx.fillText(nameInput ? nameInput+cursor : 'Type here...', W/2, boxY+boxH/2+9);

    // Keyboard
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const btnSize = Math.min(34, Math.floor((W-30)/10));
    const btnPad = 3;
    const rowLen = 10;
    const kbStartY = boxY + boxH + 12;
    const kbW = rowLen*(btnSize+btnPad);
    const kbStartX = (W-kbW)/2;
    const btnColors = ['#ff6b9d','#ff9e4d','#ffd700','#4dff88','#4dc9ff','#c44dff'];

    for (let i = 0; i < letters.length; i++) {
      const row = Math.floor(i/rowLen), col = i%rowLen;
      const bx = kbStartX+col*(btnSize+btnPad), by = kbStartY+row*(btnSize+btnPad);
      ctx.fillStyle = btnColors[i%btnColors.length];
      ctx.beginPath(); ctx.roundRect(bx, by, btnSize, btnSize, 8); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${Math.floor(btnSize*0.5)}px sans-serif`;
      ctx.fillText(letters[i], bx+btnSize/2, by+btnSize*0.65);
    }

    const ctrlY = kbStartY + 3*(btnSize+btnPad)+5;
    const ctrlBtnW = Math.min(100, W*0.25);
    ctx.fillStyle = '#ff4d8b';
    ctx.beginPath(); ctx.roundRect(W/2-ctrlBtnW-10, ctrlY, ctrlBtnW, btnSize+4, 10); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = `bold ${Math.floor(btnSize*0.4)}px sans-serif`;
    ctx.fillText('‚¨Ö Delete', W/2-ctrlBtnW/2-10, ctrlY+btnSize*0.7);
    ctx.fillStyle = '#4dff88';
    ctx.beginPath(); ctx.roundRect(W/2+10, ctrlY, ctrlBtnW, btnSize+4, 10); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.fillText('‚úÖ Done!', W/2+ctrlBtnW/2+10, ctrlY+btnSize*0.7);

    window._nameKB = { letters, btnSize, btnPad, rowLen, kbStartX, kbStartY, ctrlY, ctrlBtnW };
  } else {
    // Win screen
    const bounce = Math.abs(Math.sin(winTime*5))*20;
    ctx.font = `${60+Math.sin(winTime*3)*8}px sans-serif`;
    ctx.fillText('ü¶Ñ', W/2, H*0.18-bounce);
    ctx.font = '50px sans-serif';
    ctx.fillText('üåà', W/2, H*0.08);

    const wColors = ['#ff6b9d','#ff9e4d','#ffd700','#4dff88','#4dc9ff','#c44dff'];
    ctx.font = `bold ${Math.min(40,W*0.07)}px sans-serif`;
    const msg = 'YOU DID IT!';
    const mw = ctx.measureText(msg);
    const msx = W/2-mw.width/2;
    for (let i = 0; i < msg.length; i++) {
      ctx.fillStyle = wColors[Math.floor((i+winTime*5)%wColors.length)];
      const cw = ctx.measureText(msg[i]).width;
      const yOff = Math.sin(winTime*4+i*0.4)*8;
      ctx.fillText(msg[i], msx+ctx.measureText(msg.substring(0,i)).width+cw/2, H*0.33+yOff);
    }

    ctx.fillStyle = '#fff';
    ctx.font = `${Math.min(22,W*0.04)}px sans-serif`;
    ctx.fillText(`You collected ${score} rainbow points! ‚ú®`, W/2, H*0.41);

    // Check if NOT in top 10
    const minTop10 = leaderboard.length >= 10 ? leaderboard[leaderboard.length-1].score : 0;
    if (window._nameSubmitted || (score <= minTop10 && leaderboard.length >= 10)) {
      if (!window._nameSubmitted && score <= minTop10) {
        ctx.fillStyle = '#c9a0ff';
        ctx.font = `${Math.min(18,W*0.033)}px sans-serif`;
        ctx.fillText(`Great run! Top 10 starts at ${minTop10} points ‚Äî keep trying! üåü`, W/2, H*0.48);
      }
    }

    // Leaderboard
    const allScores = leaderboard;
    if (allScores.length > 0) {
      ctx.fillStyle = '#ffd700';
      ctx.font = `bold ${Math.min(16,W*0.032)}px sans-serif`;
      ctx.fillText('üèÜ Top 10 üèÜ', W/2, H*0.54);
      const lbS = Math.min(13,W*0.026);
      ctx.font = `${lbS}px sans-serif`;
      allScores.slice(0,10).forEach((s,i) => {
        const medal = i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':'‚≠ê';
        ctx.fillStyle = i<3?'#ffd700':'#ccc';
        ctx.fillText(`${medal} ${s.name} ‚Äî ${s.score}pts`, W/2, H*0.54+18+i*(lbS+5));
      });
    }

    ctx.font = '26px sans-serif';
    ctx.fillText('üéâ ü¶Ñ üåà ‚≠ê üíñ üéâ', W/2, H*0.85);

    if (winTime > 2) {
      const pulse = 0.7+Math.sin(winTime*3)*0.3;
      ctx.globalAlpha = pulse;
      ctx.fillStyle = '#ffd700';
      ctx.font = `bold ${Math.min(22,W*0.04)}px sans-serif`;
      ctx.fillText('üåü Tap to Race Again! üåü', W/2, H*0.92);
      ctx.globalAlpha = 1;
    }
  }
}

// --- Main Draw ---
function draw() {
  ctx.clearRect(0, 0, W, H);

  if (gameState === 'title') { drawTitle(); return; }
  if (gameState === 'win') { drawWinScreen(); return; }

  // --- Playing ---
  drawPlayBackground();

  // Rainbow trail behind unicorn
  const trailColors = ['#ff6b9d','#ff9e4d','#ffd700','#4dff88','#4dc9ff','#c44dff'];
  if (unicorn.trail.length > 1) {
    unicorn.trail.forEach((t, i) => {
      if (i===0) return;
      ctx.globalAlpha = t.life * 0.4;
      ctx.strokeStyle = trailColors[i%trailColors.length];
      ctx.lineWidth = t.life * 5;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(unicorn.trail[i-1].x, unicorn.trail[i-1].y + (i-1)*2);
      ctx.lineTo(t.x, t.y + i*2);
      ctx.stroke();
    });
    ctx.globalAlpha = 1;
  }

  // Draw rainbows on screen
  const viewRange = 600;
  trackRainbows.forEach((rb, i) => {
    if (collectedSet.has(i)) return;
    const relY = (rb.y - distance) / viewRange;
    if (relY < -0.05 || relY > 1.05) return;
    const screenY = H * (1 - relY * 0.85 - 0.08);
    const screenX = rb.x * W;
    const bob = Math.sin(Date.now()/400 + i) * 5;
    drawRainbow(screenX, screenY + bob, rb.type);
  });

  // Draw finish rainbow if visible
  const finishRelY = (TRACK_LENGTH - distance) / viewRange;
  if (finishRelY >= -0.1 && finishRelY <= 1.1) {
    const finishScreenY = H * (1 - finishRelY * 0.85 - 0.08);
    drawFinishRainbow(finishScreenY);
  }

  // Draw unicorn
  const ux = unicorn.x * W;
  const uy = H * 0.72;
  drawUnicorn(ux, uy, unicorn.sparkle);

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
    if (p.type==='star') drawStar(p.x,p.y,p.size,4,p.color);
    else { ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); }
  });
  ctx.globalAlpha = 1;

  drawHUD();
}

// --- Loop ---
function gameLoop(timestamp) {
  const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
  lastTime = timestamp;
  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

// --- Start ---
initBGClouds();
generateTrack();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
