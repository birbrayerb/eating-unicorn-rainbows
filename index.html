<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ü¶Ñ Eating Unicorn Rainbows üåà</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html, body { width:100%; height:100%; overflow:hidden; background:#1a0a2e; touch-action:none; user-select:none; -webkit-user-select:none; }
canvas { display:block; width:100%; height:100%; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// ============================================================
// ü¶Ñ EATING UNICORN RAINBOWS ‚Äî Ultimate Edition v2 üåà
// ============================================================

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;
const DPR = window.devicePixelRatio || 1;
function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
resize();
window.addEventListener('resize', resize);

// --- Audio ---
let audioCtx;
function initAudio() { if (audioCtx) return; audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playChime(freq, dur=0.15, vol=0.12, type='sine') {
  if (!audioCtx) return;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
}

function playEatSound(pts) {
  const base = pts >= 100 ? 880 : pts >= 50 ? 660 : 523;
  playChime(base, 0.2, 0.1);
  setTimeout(() => playChime(base * 1.25, 0.15, 0.08), 50);
  if (pts >= 50) setTimeout(() => playChime(base * 1.5, 0.12, 0.06), 100);
}

function playObstacleHit() {
  playChime(150, 0.3, 0.15, 'sawtooth');
  setTimeout(() => playChime(120, 0.2, 0.1, 'sawtooth'), 80);
}

function playPowerUp() {
  [523,659,784,1047].forEach((f,i) => setTimeout(() => playChime(f, 0.15, 0.1, 'triangle'), i*60));
}

function playComboBreak() {
  playChime(200, 0.3, 0.1, 'square');
  setTimeout(() => playChime(150, 0.3, 0.08, 'square'), 100);
}

function playWinFanfare() {
  const notes = [523,659,784,1047,784,1047,1319,1047,1319,1568];
  notes.forEach((f,i) => setTimeout(() => playChime(f, 0.4, 0.12, i%2?'sine':'triangle'), i*150));
}

function playNearMiss() {
  playChime(900, 0.1, 0.08, 'sine');
  setTimeout(() => playChime(1200, 0.08, 0.06, 'sine'), 40);
}

function playRainbowBurst() {
  const notes = [523, 659, 784, 988, 1175, 1397, 1568, 1760];
  notes.forEach((f,i) => setTimeout(() => playChime(f, 0.25, 0.1, 'triangle'), i*50));
}

function playCoinSound() {
  playChime(1200, 0.1, 0.1, 'sine');
  setTimeout(() => playChime(1600, 0.15, 0.08, 'sine'), 60);
}

function playLevelUp() {
  [440,554,659,880].forEach((f,i) => setTimeout(() => playChime(f, 0.2, 0.1, 'triangle'), i*80));
}

function playMissionComplete() {
  [660,880,1100,1320,1100,1320,1568].forEach((f,i) => setTimeout(() => playChime(f, 0.2, 0.08, 'triangle'), i*70));
}

let melodyInterval;
function startMelody() {
  if (melodyInterval) return;
  const scale = [262,294,330,349,392,440,494,523,494,440,392,349,330,294];
  let idx = 0;
  melodyInterval = setInterval(() => {
    if (gameState !== 'playing') return;
    playChime(scale[idx % scale.length], 0.3, 0.03, 'triangle');
    idx++;
  }, 600);
}
function stopMelody() { clearInterval(melodyInterval); melodyInterval = null; }

// --- Seeded Random ---
function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}

// --- Curving Lane ---
function getLaneCenterOffset(trackY, aggressiveness) {
  const a = aggressiveness || 1;
  return Math.sin(trackY * 0.0008) * 0.15 * a + Math.sin(trackY * 0.0003 + 2.5) * 0.1 * a;
}

// --- Track Lengths per Difficulty ---
const TRACK_LENGTHS = {
  easy: 10000,
  medium: 13000,
  hard: 16000,
  extreme: 20000,
  crazy: 26000,
};

// --- Difficulty Levels ---
const DIFFICULTIES = {
  easy:    { label: 'Easy',    emoji: 'üå∏', speed: 125, spacing: 60,  hitMult: 1.0,  seed: 42069, color: '#ffb6d9', bg: '#ff69b4', sway: false },
  medium:  { label: 'Medium',  emoji: '‚≠ê', speed: 160, spacing: 75,  hitMult: 0.95, seed: 31337, color: '#b69fff', bg: '#7c4dff', sway: false },
  hard:    { label: 'Hard',    emoji: 'üî•', speed: 200, spacing: 90,  hitMult: 0.85, seed: 80085, color: '#ffb347', bg: '#ff6b35', sway: false },
  extreme: { label: 'Extreme', emoji: 'üíÄ', speed: 250, spacing: 110, hitMult: 0.75, seed: 66642, color: '#ff4444', bg: '#8b0000', sway: false },
  crazy:   { label: 'Crazy',   emoji: 'ü§Ø', speed: 320, spacing: 130, hitMult: 0.65, seed: 99999, color: '#ff00ff', bg: '#222',    sway: true  },
};
const DIFFICULTY_ORDER = ['easy','medium','hard','extreme','crazy'];
let currentDifficulty = 'easy';
let selectedDifficultyForLB = 'easy';

// --- Game Mode ---
let gameMode = 'race'; // 'race' or 'endless'

// --- Skins System ---
const SKINS = [
  { id: 'default', name: 'Default', threshold: 0, bodyColor: '#fff', strokeColor: '#e8d5f0', particleColors: ['#ff6b9d','#4dc9ff','#ffd700'] },
  { id: 'pink', name: 'Pink Sparkle', threshold: 500, bodyColor: '#ffb6d9', strokeColor: '#ff69b4', particleColors: ['#ff69b4','#ff9ec4','#fff0f5'] },
  { id: 'galaxy', name: 'Galaxy', threshold: 2000, bodyColor: '#4a0e6b', strokeColor: '#8b5cf6', particleColors: ['#8b5cf6','#06b6d4','#f0abfc'] },
  { id: 'golden', name: 'Golden', threshold: 5000, bodyColor: '#ffd700', strokeColor: '#daa520', particleColors: ['#ffd700','#ffec80','#fff8dc'] },
  { id: 'rainbow', name: 'Rainbow', threshold: 10000, bodyColor: 'rainbow', strokeColor: '#fff', particleColors: ['#ff0000','#ff8800','#ffdd00','#00cc44','#0088ff','#cc44cc'] },
  { id: 'diamond', name: 'Diamond', threshold: 25000, bodyColor: 'rgba(200,230,255,0.7)', strokeColor: '#e0f0ff', particleColors: ['#e0f0ff','#c0e0ff','#ffffff'] },
];

function loadCumulativeScore() { return parseInt(localStorage.getItem('unicorn_cumulative_score') || '0'); }
function saveCumulativeScore(s) { localStorage.setItem('unicorn_cumulative_score', String(s)); }
function loadSelectedSkin() { return localStorage.getItem('unicorn_selected_skin') || 'default'; }
function saveSelectedSkin(id) { localStorage.setItem('unicorn_selected_skin', id); }

let cumulativeScore = loadCumulativeScore();
let selectedSkin = loadSelectedSkin();

function getSkin() { return SKINS.find(s => s.id === selectedSkin) || SKINS[0]; }
function isSkinUnlocked(skin) { return cumulativeScore >= skin.threshold; }

// --- Coins System ---
function loadCoins() { return parseInt(localStorage.getItem('unicorn_coins') || '0'); }
function saveCoins(c) { localStorage.setItem('unicorn_coins', String(c)); }
let coinBalance = loadCoins();

// Shop items (one-time use per run)
let shopItems = [
  { id: 'headstart', name: 'Head Start', icon: 'üöÄ', desc: 'Start 10% further', price: 50 },
  { id: 'magnet', name: 'Coin Magnet', icon: 'üß≤', desc: 'Start with magnet', price: 75 },
  { id: 'extralife', name: 'Extra Life', icon: '‚ù§Ô∏è', desc: '4th life (endless)', price: 100 },
  { id: 'scoreboost', name: 'Score Boost', icon: '‚≠ê', desc: '1.5x score multiplier', price: 60 },
];
function loadPurchasedItems() {
  try { return JSON.parse(localStorage.getItem('unicorn_purchased_items') || '[]'); } catch(e) { return []; }
}
function savePurchasedItems(items) { localStorage.setItem('unicorn_purchased_items', JSON.stringify(items)); }
let purchasedItems = loadPurchasedItems();

// Active boosts for current run
let activeBoosts = {};

// --- Missions System ---
const MISSION_TEMPLATES = [
  { type: 'gold_rainbows', desc: 'Collect {X} gold rainbows in one run', targets: [3, 5, 8], stat: 'goldRainbows' },
  { type: 'combo', desc: 'Get a {X}x combo', targets: [10, 15, 20], stat: 'maxCombo' },
  { type: 'no_clouds', desc: 'Finish a race without hitting clouds', targets: [1], stat: 'noCloudHit' },
  { type: 'total_rainbows', desc: 'Collect {X} rainbows in one run', targets: [30, 50, 75], stat: 'totalRainbows' },
  { type: 'powerups', desc: 'Use {X} power-ups in one run', targets: [3, 5], stat: 'powerupsUsed' },
  { type: 'endless_distance', desc: 'Travel {X} in endless mode', targets: [5000, 10000, 20000], stat: 'endlessDistance' },
  { type: 'rainbow_bursts', desc: 'Trigger {X} Rainbow Bursts', targets: [1, 2, 3], stat: 'rainbowBursts' },
];

function loadMissions() {
  try { 
    const m = JSON.parse(localStorage.getItem('unicorn_missions') || 'null');
    if (m && m.length === 3) return m;
    return null;
  } catch(e) { return null; }
}
function saveMissions(m) { localStorage.setItem('unicorn_missions', JSON.stringify(m)); }

function generateMission() {
  const tmpl = MISSION_TEMPLATES[Math.floor(Math.random() * MISSION_TEMPLATES.length)];
  const target = tmpl.targets[Math.floor(Math.random() * tmpl.targets.length)];
  return {
    type: tmpl.type,
    desc: tmpl.desc.replace('{X}', target),
    target: target,
    stat: tmpl.stat,
    completed: false,
  };
}

let missions = loadMissions() || [generateMission(), generateMission(), generateMission()];
saveMissions(missions);

// Run stats for missions
let runStats = {};
function resetRunStats() {
  runStats = {
    goldRainbows: 0,
    maxCombo: 0,
    noCloudHit: true,
    totalRainbows: 0,
    powerupsUsed: 0,
    endlessDistance: 0,
    rainbowBursts: 0,
  };
}

let missionCompleteQueue = []; // messages to show

// --- Ghost System ---
function loadGhostData(diff) {
  try { return JSON.parse(localStorage.getItem(`unicorn_ghost_${diff}`) || 'null'); } catch(e) { return null; }
}
function saveGhostData(diff, data) { localStorage.setItem(`unicorn_ghost_${diff}`, JSON.stringify(data)); }

let ghostData = null; // loaded ghost for current difficulty
let currentRunPositions = []; // recording current run positions
let ghostVisible = true;

// --- Track Generation ---
let trackRainbows = [];
let trackObstacles = [];
let trackPowerUps = [];
let trackCoins = [];
let trackStars = [];
let trackSeed = 0;
let isDailyChallenge = false;
let currentTrackLength = 10000;

function getDailySeed() {
  const d = new Date();
  return d.getFullYear() * 10000 + (d.getMonth()+1) * 100 + d.getDate();
}

function getTrackLength() {
  if (gameMode === 'endless') return Infinity;
  return TRACK_LENGTHS[currentDifficulty] || 10000;
}

function generateTrack(seed) {
  const diff = DIFFICULTIES[currentDifficulty];
  currentTrackLength = getTrackLength();
  const TL = gameMode === 'endless' ? 10000 : currentTrackLength; // initial generation length for race
  trackSeed = seed !== undefined ? seed : (diff.seed ^ (Date.now() & 0xFFFFFF));
  const rng = seededRandom(trackSeed);
  
  trackRainbows = [];
  trackObstacles = [];
  trackPowerUps = [];
  trackCoins = [];
  trackStars = [];

  if (gameMode === 'endless') {
    // Generate initial chunk
    endlessGenerated = 0;
    generateEndlessChunk(0, 3000, rng);
    endlessRng = rng;
    endlessGenerated = 3000;
    return;
  }

  // Race mode track generation
  for (let y = 200; y < TL - 200; y += diff.spacing) {
    const r = rng();
    const laneOffset = getLaneCenterOffset(y);
    const baseX = 0.5 + laneOffset;
    const spread = 0.25;
    const x = baseX + (rng() - 0.5) * spread * 2;
    const clampedX = Math.max(0.08, Math.min(0.92, x));
    
    if (r < 0.45) {
      trackRainbows.push({ y, x: clampedX, type: 'small', points: 10, swayOffset: rng()*Math.PI*2 });
    } else if (r < 0.58) {
      trackRainbows.push({ y, x: clampedX, type: 'big', points: 50, swayOffset: rng()*Math.PI*2 });
    } else if (r < 0.62) {
      trackRainbows.push({ y, x: clampedX, type: 'gold', points: 100, swayOffset: rng()*Math.PI*2 });
    }
  }

  // Coins (rarer than rainbows)
  for (let y = 300; y < TL - 300; y += 200 + rng() * 300) {
    if (rng() < 0.3) {
      const laneOffset = getLaneCenterOffset(y);
      const baseX = 0.5 + laneOffset;
      const x = Math.max(0.08, Math.min(0.92, baseX + (rng() - 0.5) * 0.4));
      trackCoins.push({ y, x, swayOffset: rng()*Math.PI*2 });
    }
  }

  for (let y = 400; y < TL - 300; y += Math.max(40, 120 - (y / TL) * 80)) {
    const r = rng();
    const progress = y / TL;
    const spawnChance = 0.15 + progress * 0.35;
    if (r < spawnChance) {
      const laneOffset = getLaneCenterOffset(y);
      const baseX = 0.5 + laneOffset;
      const x = Math.max(0.08, Math.min(0.92, baseX + (rng() - 0.5) * 0.5));
      const obstType = rng() < 0.6 ? 'cloud' : 'star';
      trackObstacles.push({
        y, x, type: obstType,
        slowDuration: obstType === 'cloud' ? 2.0 : 1.5,
        swayOffset: rng() * Math.PI * 2,
        rotation: rng() * Math.PI * 2,
        nearMissTriggered: false,
      });
    }
  }

  for (let y = 600; y < TL - 500; y += 300 + rng() * 200) {
    if (rng() < 0.5) {
      const laneOffset = getLaneCenterOffset(y);
      const baseX = 0.5 + laneOffset;
      const x = Math.max(0.1, Math.min(0.9, baseX + (rng() - 0.5) * 0.3));
      const types = ['magnet', 'shield', 'rocket', 'giant'];
      const type = types[Math.floor(rng() * types.length)];
      trackPowerUps.push({ y, x, type, swayOffset: rng() * Math.PI * 2 });
    }
  }

  for (let y = 0; y < TL; y += 30) {
    if (rng() < 0.3) {
      trackStars.push({ y, x: rng(), size: rng()*2+1, twinkleOffset: rng()*Math.PI*2 });
    }
  }
}

// --- Endless Mode ---
let endlessRng = null;
let endlessGenerated = 0;
let endlessLives = 3;
let endlessSpeed = 125;
let endlessTime = 0;
let endlessLevelUpTimer = 0;
let endlessLevelUpFlash = 0;
let endlessLevel = 1;
let lostLifeAnim = 0;

function generateEndlessChunk(fromY, toY, rng) {
  const progress = fromY / 10000; // escalation factor
  const density = Math.min(2.5, 1 + progress * 0.3);
  const curveAggr = Math.min(3, 1 + progress * 0.2);
  
  // Rainbows
  const spacing = Math.max(30, 60 - progress * 5);
  for (let y = fromY; y < toY; y += spacing) {
    const r = rng();
    const laneOffset = getLaneCenterOffset(y, curveAggr);
    const baseX = 0.5 + laneOffset;
    const x = Math.max(0.08, Math.min(0.92, baseX + (rng() - 0.5) * 0.5));
    if (r < 0.45) {
      trackRainbows.push({ y, x, type: 'small', points: 10, swayOffset: rng()*Math.PI*2 });
    } else if (r < 0.58) {
      trackRainbows.push({ y, x, type: 'big', points: 50, swayOffset: rng()*Math.PI*2 });
    } else if (r < 0.62) {
      trackRainbows.push({ y, x, type: 'gold', points: 100, swayOffset: rng()*Math.PI*2 });
    }
  }

  // Coins
  for (let y = fromY; y < toY; y += 200 + rng() * 300) {
    if (rng() < 0.3) {
      const laneOffset = getLaneCenterOffset(y, curveAggr);
      const baseX = 0.5 + laneOffset;
      const x = Math.max(0.08, Math.min(0.92, baseX + (rng() - 0.5) * 0.4));
      trackCoins.push({ y, x, swayOffset: rng()*Math.PI*2 });
    }
  }

  // Obstacles ‚Äî denser over time
  const obstSpacing = Math.max(25, 100 - progress * 15);
  for (let y = fromY; y < toY; y += obstSpacing) {
    const r = rng();
    const spawnChance = Math.min(0.7, 0.2 + progress * 0.15);
    if (r < spawnChance) {
      const laneOffset = getLaneCenterOffset(y, curveAggr);
      const baseX = 0.5 + laneOffset;
      const x = Math.max(0.08, Math.min(0.92, baseX + (rng() - 0.5) * 0.5));
      const obstType = rng() < 0.6 ? 'cloud' : 'star';
      trackObstacles.push({
        y, x, type: obstType,
        slowDuration: obstType === 'cloud' ? 2.0 : 1.5,
        swayOffset: rng() * Math.PI * 2,
        rotation: rng() * Math.PI * 2,
        nearMissTriggered: false,
      });
    }
  }

  // Power-ups
  for (let y = fromY; y < toY; y += 300 + rng() * 200) {
    if (rng() < 0.5) {
      const laneOffset = getLaneCenterOffset(y, curveAggr);
      const baseX = 0.5 + laneOffset;
      const x = Math.max(0.1, Math.min(0.9, baseX + (rng() - 0.5) * 0.3));
      const types = ['magnet', 'shield', 'rocket', 'giant'];
      const type = types[Math.floor(rng() * types.length)];
      trackPowerUps.push({ y, x, type, swayOffset: rng() * Math.PI * 2 });
    }
  }

  // Stars
  for (let y = fromY; y < toY; y += 30) {
    if (rng() < 0.3) {
      trackStars.push({ y, x: rng(), size: rng()*2+1, twinkleOffset: rng()*Math.PI*2 });
    }
  }
}

function cleanupEndlessEntities() {
  const cutoff = distance - 1000;
  trackRainbows = trackRainbows.filter(r => r.y > cutoff);
  trackObstacles = trackObstacles.filter(o => o.y > cutoff);
  trackPowerUps = trackPowerUps.filter(p => p.y > cutoff);
  trackCoins = trackCoins.filter(c => c.y > cutoff);
  trackStars = trackStars.filter(s => s.y > cutoff);
}

// --- Rainbow Burst ---
let rainbowBurstEffect = 0;
let rainbowBurstRadius = 0;
let lastBurstCombo = 0;

// --- Near Miss ---
let nearMissFlash = 0;

// --- Leaderboard ---
let leaderboard = [];
let showingNameEntry = false;
let pendingScore = 0;
let nameInput = '';
let leaderboards = { easy:[], medium:[], hard:[], extreme:[], crazy:[], endless:[] };

async function fetchLeaderboard(diff) {
  diff = diff || selectedDifficultyForLB;
  try {
    const r = await fetch(`/api/scores?difficulty=${diff}`);
    const d = await r.json();
    if (d.scores) { leaderboards[diff] = d.scores; leaderboard = leaderboards[diff]; }
  } catch(e) { console.log('Leaderboard offline'); }
}

async function submitScore(name, sc) {
  try {
    const diff = gameMode === 'endless' ? 'endless' : currentDifficulty;
    const r = await fetch('/api/scores', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, score: sc, difficulty: diff, daily: isDailyChallenge })
    });
    const d = await r.json();
    if (d.scores) { leaderboards[diff] = d.scores; leaderboard = d.scores; }
  } catch(e) { console.log('Could not submit score'); }
}

fetchLeaderboard('easy');

// --- Game State ---
let gameState = 'title'; // title, playing, win, shop
let score = 0;
let distance = 0;
let titleTime = 0;
let winTime = 0;
let collectedSet = new Set();
let collectedObstacles = new Set();
let collectedPowerUps = new Set();
let collectedCoins = new Set();
let coinsCollectedThisRun = 0;

// Combo system
let combo = 0;
let comboTimer = 0;
let lastComboText = '';
let comboBreakEffect = 0;

// Floating texts
let floatingTexts = [];

// Power-up state
let activePowerUp = null;

// Slow effect
let slowTimer = 0;
let slowFactor = 1.0;

// Sprint
let sprintActive = false;
let sprintFlashTimer = 0;

// Screen shake
let shakeAmount = 0;

// Title scroll
let titleScrollY = 0;
let titleMaxScroll = 0;

// Speed
function getBaseSpeed() {
  if (gameMode === 'endless') return endlessSpeed;
  return DIFFICULTIES[currentDifficulty].speed;
}

function getCurrentSpeed() {
  const base = getBaseSpeed();
  let speed = base;
  if (gameMode === 'race') {
    const TL = currentTrackLength;
    const progress = distance / TL;
    speed = base * (1 + progress * 0.3);
    if (progress >= 0.8) speed *= 1.4;
  }
  if (slowTimer > 0) speed *= 0.4;
  if (activePowerUp && activePowerUp.type === 'rocket') speed *= 2.0;
  return speed;
}

function getComboMultiplier() {
  let mult = 1;
  if (combo >= 10) mult = 3;
  else if (combo >= 6) mult = 2;
  else if (combo >= 3) mult = 1.5;
  if (activeBoosts.scoreboost) mult *= 1.5;
  return mult;
}

// --- Unicorn ---
const unicorn = {
  x: 0.5,
  trail: [],
  sparkle: 0,
  blinkTimer: 3,
  scale: 1,
};

const UNICORN_MOVE_SPEED = 1.8;
let moveDir = 0;

// --- Particles & effects ---
let particles = [];
let fireworks = [];
let bgClouds = [];

function initBGClouds() {
  bgClouds = [];
  for (let i = 0; i < 8; i++) {
    bgClouds.push({ x: Math.random(), y: Math.random()*H, w: Math.random()*150+80, alpha: Math.random()*0.15+0.05 });
  }
}

function spawnParticles(x, y, color, count=8, spread=3) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random()*Math.PI*2;
    const speed = Math.random()*spread+1;
    particles.push({
      x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
      life: 1, decay: 0.015+Math.random()*0.02,
      color, size: Math.random()*5+2,
      type: Math.random()<0.3 ? 'star' : 'circle',
    });
  }
}

function spawnFirework(x, y) {
  const colors = ['#ff6b9d','#ffd700','#4dc9ff','#c44dff','#4dff88','#ff9e4d','#fff'];
  const c = colors[Math.floor(Math.random()*colors.length)];
  for (let i = 0; i < 30; i++) {
    const angle = Math.random()*Math.PI*2;
    const speed = Math.random()*6+2;
    fireworks.push({
      x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed-2,
      life: 1, decay: 0.01+Math.random()*0.015, color: c, size: Math.random()*4+2,
    });
  }
}

function addFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 1.0, vy: -1.5 });
}

// --- Input ---
let keys = {};
let touchTargetX = null;
let touchActive = false;

document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  initAudio();
  if (showingNameEntry) {
    if (e.key === 'Backspace') { nameInput = nameInput.slice(0,-1); e.preventDefault(); return; }
    if (e.key === 'Enter' && nameInput.length > 0) { finishNameEntry(); return; }
    if (/^[a-zA-Z0-9 ]$/.test(e.key) && nameInput.length < 12) { nameInput += e.key.toUpperCase(); }
  }
});
document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('pointerdown', e => {
  initAudio();
  if (gameState === 'title') { handleTitleClick(e.clientX, e.clientY); return; }
  if (gameState === 'shop') { handleShopClick(e.clientX, e.clientY); return; }
  if (gameState === 'win') {
    if (showingNameEntry) { handleNameClick(e.clientX, e.clientY); return; }
    if (winTime > 2) { resetToTitle(); return; }
  }
  touchTargetX = e.clientX;
  touchActive = true;
});
canvas.addEventListener('pointermove', e => {
  if (gameState === 'title') { return; }
  if (gameState !== 'playing') return;
  if (touchActive) touchTargetX = e.clientX;
});
canvas.addEventListener('pointerup', e => { touchActive = false; });
canvas.addEventListener('pointercancel', e => { touchActive = false; });

// Touch scroll for title
let titleTouchStartY = null;
let titleTouchLastY = null;
canvas.addEventListener('touchstart', e => {
  if (gameState === 'title') {
    titleTouchStartY = e.touches[0].clientY;
    titleTouchLastY = e.touches[0].clientY;
  }
}, { passive: true });
canvas.addEventListener('touchmove', e => {
  if (gameState === 'title' && titleTouchLastY !== null) {
    const dy = titleTouchLastY - e.touches[0].clientY;
    titleScrollY = Math.max(0, Math.min(titleMaxScroll, titleScrollY + dy));
    titleTouchLastY = e.touches[0].clientY;
  }
}, { passive: true });
canvas.addEventListener('touchend', e => {
  titleTouchStartY = null;
  titleTouchLastY = null;
});

// Mouse wheel for title scroll
canvas.addEventListener('wheel', e => {
  if (gameState === 'title') {
    titleScrollY = Math.max(0, Math.min(titleMaxScroll, titleScrollY + e.deltaY * 0.5));
  }
});

// --- Name Entry ---
function handleNameClick(cx, cy) {
  const kb = window._nameKB;
  if (!kb) return;
  const { letters, btnSize, btnPad, rowLen, kbStartX, kbStartY, ctrlY, ctrlBtnW } = kb;
  for (let i = 0; i < letters.length; i++) {
    const row = Math.floor(i / rowLen);
    const col = i % rowLen;
    const bx = kbStartX + col * (btnSize + btnPad);
    const by = kbStartY + row * (btnSize + btnPad);
    if (cx >= bx && cx <= bx+btnSize && cy >= by && cy <= by+btnSize) {
      if (nameInput.length < 12) { nameInput += letters[i]; playChime(400+i*20, 0.1, 0.08); }
      return;
    }
  }
  if (cx >= W/2-ctrlBtnW-10 && cx <= W/2-10 && cy >= ctrlY && cy <= ctrlY+btnSize+4) {
    nameInput = nameInput.slice(0,-1); playChime(300, 0.1, 0.06); return;
  }
  if (cx >= W/2+10 && cx <= W/2+10+ctrlBtnW && cy >= ctrlY && cy <= ctrlY+btnSize+4) {
    if (nameInput.length > 0) finishNameEntry();
    return;
  }
}

function finishNameEntry() {
  submitScore(nameInput, pendingScore);
  showingNameEntry = false;
  window._nameSubmitted = true;
  winTime = 0;
  playChime(800, 0.3, 0.1);
}

// --- Title Screen Click ---
let _diffBtns = [];
let _lbTabBtns = [];
let _startBtn = null;
let _dailyBtn = null;
let _endlessBtn = null;
let _shopBtn = null;
let _skinBtns = [];
let _shopBackBtn = null;
let _shopItemBtns = [];

function handleTitleClick(cx, cy) {
  // Adjust cy for scroll
  const acy = cy + titleScrollY;
  
  if (_startBtn) {
    if (cx >= _startBtn.x && cx <= _startBtn.x+_startBtn.w && acy >= _startBtn.y && acy <= _startBtn.y+_startBtn.h) {
      isDailyChallenge = false;
      gameMode = 'race';
      startGame();
      return;
    }
  }
  if (_dailyBtn) {
    if (cx >= _dailyBtn.x && cx <= _dailyBtn.x+_dailyBtn.w && acy >= _dailyBtn.y && acy <= _dailyBtn.y+_dailyBtn.h) {
      isDailyChallenge = true;
      gameMode = 'race';
      startGame(getDailySeed());
      return;
    }
  }
  if (_endlessBtn) {
    if (cx >= _endlessBtn.x && cx <= _endlessBtn.x+_endlessBtn.w && acy >= _endlessBtn.y && acy <= _endlessBtn.y+_endlessBtn.h) {
      isDailyChallenge = false;
      gameMode = 'endless';
      startGame();
      return;
    }
  }
  if (_shopBtn) {
    if (cx >= _shopBtn.x && cx <= _shopBtn.x+_shopBtn.w && acy >= _shopBtn.y && acy <= _shopBtn.y+_shopBtn.h) {
      gameState = 'shop';
      return;
    }
  }
  for (const btn of _diffBtns) {
    if (cx >= btn.x && cx <= btn.x+btn.w && acy >= btn.y && acy <= btn.y+btn.h) {
      currentDifficulty = btn.key;
      selectedDifficultyForLB = btn.key;
      leaderboard = leaderboards[btn.key] || [];
      fetchLeaderboard(btn.key);
      return;
    }
  }
  for (const btn of _skinBtns) {
    if (cx >= btn.x && cx <= btn.x+btn.w && acy >= btn.y && acy <= btn.y+btn.h) {
      if (isSkinUnlocked(btn.skin)) {
        selectedSkin = btn.skin.id;
        saveSelectedSkin(btn.skin.id);
        playChime(600, 0.15, 0.08);
      }
      return;
    }
  }
  for (const btn of _lbTabBtns) {
    if (cx >= btn.x && cx <= btn.x+btn.w && acy >= btn.y && acy <= btn.y+btn.h) {
      selectedDifficultyForLB = btn.key;
      leaderboard = leaderboards[btn.key] || [];
      fetchLeaderboard(btn.key);
      return;
    }
  }
}

function handleShopClick(cx, cy) {
  if (_shopBackBtn) {
    if (cx >= _shopBackBtn.x && cx <= _shopBackBtn.x+_shopBackBtn.w && cy >= _shopBackBtn.y && cy <= _shopBackBtn.y+_shopBackBtn.h) {
      gameState = 'title';
      return;
    }
  }
  for (const btn of _shopItemBtns) {
    if (cx >= btn.x && cx <= btn.x+btn.w && cy >= btn.y && cy <= btn.y+btn.h) {
      if (coinBalance >= btn.item.price && !purchasedItems.includes(btn.item.id)) {
        coinBalance -= btn.item.price;
        saveCoins(coinBalance);
        purchasedItems.push(btn.item.id);
        savePurchasedItems(purchasedItems);
        playCoinSound();
      }
      return;
    }
  }
}

// --- Game Flow ---
function startGame(seed) {
  gameState = 'playing';
  score = 0; distance = 0;
  unicorn.x = 0.5; unicorn.trail = []; unicorn.sparkle = 0; unicorn.scale = 1;
  collectedSet = new Set();
  collectedObstacles = new Set();
  collectedPowerUps = new Set();
  collectedCoins = new Set();
  coinsCollectedThisRun = 0;
  particles = []; fireworks = []; floatingTexts = [];
  combo = 0; comboTimer = 0; comboBreakEffect = 0;
  activePowerUp = null;
  slowTimer = 0; slowFactor = 1.0;
  sprintActive = false; sprintFlashTimer = 0;
  shakeAmount = 0;
  rainbowBurstEffect = 0;
  rainbowBurstRadius = 0;
  lastBurstCombo = 0;
  nearMissFlash = 0;
  resetRunStats();
  missionCompleteQueue = [];
  currentRunPositions = [];

  // Apply purchased boosts
  activeBoosts = {};
  const newPurchased = [];
  for (const id of purchasedItems) {
    activeBoosts[id] = true;
  }
  // Clear purchased items (consumed)
  purchasedItems = [];
  savePurchasedItems(purchasedItems);

  if (gameMode === 'endless') {
    endlessLives = 3;
    if (activeBoosts.extralife) endlessLives = 4;
    endlessSpeed = 125;
    endlessTime = 0;
    endlessLevelUpTimer = 0;
    endlessLevelUpFlash = 0;
    endlessLevel = 1;
    lostLifeAnim = 0;
    currentDifficulty = 'easy'; // for hitMult etc
  }

  generateTrack(seed);

  // Head start boost
  if (activeBoosts.headstart && gameMode === 'race') {
    distance = currentTrackLength * 0.1;
  }

  // Magnet boost
  if (activeBoosts.magnet) {
    activePowerUp = { type: 'magnet', timeLeft: 8 };
  }

  // Load ghost
  if (gameMode === 'race') {
    ghostData = loadGhostData(currentDifficulty);
  } else {
    ghostData = null;
  }

  startMelody();
}

function resetToTitle() {
  gameState = 'title'; titleTime = 0;
  stopMelody();
  particles = []; fireworks = [];
  selectedDifficultyForLB = gameMode === 'endless' ? 'endless' : currentDifficulty;
  fetchLeaderboard(selectedDifficultyForLB);
}

// --- Check missions ---
function checkMissions() {
  for (let i = 0; i < missions.length; i++) {
    if (missions[i].completed) continue;
    const m = missions[i];
    let complete = false;
    
    if (m.type === 'no_clouds') {
      // Checked at end of race
      continue;
    }
    
    if (m.stat === 'maxCombo') {
      if (runStats.maxCombo >= m.target) complete = true;
    } else if (m.stat === 'endlessDistance') {
      if (gameMode === 'endless' && distance >= m.target) complete = true;
    } else if (runStats[m.stat] >= m.target) {
      complete = true;
    }
    
    if (complete) {
      missions[i].completed = true;
      coinBalance += 25;
      saveCoins(coinBalance);
      missionCompleteQueue.push(m.desc);
      playMissionComplete();
    }
  }
}

function finalizeMissions() {
  // Check no-clouds mission
  for (let i = 0; i < missions.length; i++) {
    if (missions[i].completed) continue;
    if (missions[i].type === 'no_clouds' && gameMode === 'race') {
      if (runStats.noCloudHit) {
        missions[i].completed = true;
        coinBalance += 25;
        saveCoins(coinBalance);
        missionCompleteQueue.push(missions[i].desc);
      }
    }
  }
  // Replace completed missions
  for (let i = 0; i < missions.length; i++) {
    if (missions[i].completed) {
      missions[i] = generateMission();
    }
  }
  saveMissions(missions);
}

// --- Combo check: detect missed rainbows ---
function checkMissedRainbows() {
  const viewRange = 600;
  const laneWidth = 0.3;
  trackRainbows.forEach((rb, i) => {
    if (collectedSet.has(i)) return;
    if (rb._missed) return;
    const relY = (rb.y - distance) / viewRange;
    if (relY < -0.05) {
      const laneCenter = 0.5 + getLaneCenterOffset(rb.y);
      if (Math.abs(rb.x - laneCenter) < laneWidth) {
        rb._missed = true;
        if (combo >= 3) {
          comboBreakEffect = 1.0;
          playComboBreak();
        }
        combo = 0;
      }
    }
  });
}

// --- Update ---
let lastTime = 0;
let missionCompleteDisplayTimer = 0;
let missionCompleteText = '';

function update(dt) {
  if (gameState === 'title' || gameState === 'shop') { titleTime += dt; return; }
  if (gameState === 'win') {
    winTime += dt;
    if (Math.random() < 0.15) spawnFirework(Math.random()*W, Math.random()*H*0.6);
    fireworks.forEach(f => { f.x += f.vx; f.y += f.vy; f.vy += 0.05; f.life -= f.decay; });
    fireworks = fireworks.filter(f => f.life > 0);
    particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= p.decay; });
    particles = particles.filter(p => p.life > 0);
    return;
  }

  // --- Playing ---
  const speed = getCurrentSpeed();
  distance += speed * dt;

  // Endless mode updates
  if (gameMode === 'endless') {
    endlessTime += dt;
    runStats.endlessDistance = Math.floor(distance);
    
    // Speed ramp: increase by ~5 every 30 seconds
    endlessSpeed = 125 + endlessTime * (5/30);
    
    // Level up every 30 seconds
    endlessLevelUpTimer += dt;
    if (endlessLevelUpTimer >= 30) {
      endlessLevelUpTimer -= 30;
      endlessLevel++;
      endlessLevelUpFlash = 2.0;
      playLevelUp();
    }
    if (endlessLevelUpFlash > 0) endlessLevelUpFlash -= dt;
    if (lostLifeAnim > 0) lostLifeAnim -= dt * 3;

    // Generate more chunks ahead
    if (distance + 2000 > endlessGenerated) {
      const from = endlessGenerated;
      const to = endlessGenerated + 2000;
      generateEndlessChunk(from, to, endlessRng);
      endlessGenerated = to;
    }
    // Cleanup
    if (distance > 2000) cleanupEndlessEntities();
  }

  // Race mode
  if (gameMode === 'race') {
    const TL = currentTrackLength;
    const progress = distance / TL;
    if (progress >= 0.8 && !sprintActive) {
      sprintActive = true;
      sprintFlashTimer = 2.0;
    }
    if (sprintFlashTimer > 0) sprintFlashTimer -= dt;

    // Record ghost position
    const checkpoint = Math.floor(distance / 100);
    while (currentRunPositions.length <= checkpoint) {
      currentRunPositions.push(unicorn.x);
    }
  }

  // Slow timer
  if (slowTimer > 0) slowTimer -= dt;

  // Power-up timer
  if (activePowerUp) {
    activePowerUp.timeLeft -= dt;
    if (activePowerUp.timeLeft <= 0) {
      if (activePowerUp.type === 'giant') unicorn.scale = 1;
      activePowerUp = null;
    }
  }

  // Giant mode scale
  if (activePowerUp && activePowerUp.type === 'giant') {
    unicorn.scale = Math.min(2, unicorn.scale + dt * 4);
  } else {
    unicorn.scale = Math.max(1, unicorn.scale - dt * 4);
  }

  // Screen shake decay
  if (shakeAmount > 0) shakeAmount *= 0.92;

  // Near miss flash decay
  if (nearMissFlash > 0) nearMissFlash -= dt * 4;

  // Rainbow burst effect
  if (rainbowBurstEffect > 0) {
    rainbowBurstEffect -= dt * 1.5;
    rainbowBurstRadius += dt * 800;
  }

  // Mission complete display
  if (missionCompleteDisplayTimer > 0) {
    missionCompleteDisplayTimer -= dt;
  } else if (missionCompleteQueue.length > 0) {
    missionCompleteText = missionCompleteQueue.shift();
    missionCompleteDisplayTimer = 3.0;
  }

  // Check win (race mode)
  if (gameMode === 'race' && distance >= currentTrackLength) {
    distance = currentTrackLength;
    gameState = 'win'; winTime = 0;
    playWinFanfare();
    for (let i=0;i<10;i++) spawnFirework(Math.random()*W, Math.random()*H*0.5);
    cumulativeScore += score;
    saveCumulativeScore(cumulativeScore);
    // Award coins
    const bonusCoins = Math.floor(score / 100);
    coinBalance += coinsCollectedThisRun + bonusCoins;
    saveCoins(coinBalance);
    // Save ghost if best
    const prevGhost = loadGhostData(currentDifficulty);
    if (!prevGhost || score > prevGhost.score) {
      saveGhostData(currentDifficulty, { score, positions: currentRunPositions });
    }
    finalizeMissions();
    const diff = gameMode === 'endless' ? 'endless' : currentDifficulty;
    const lb = leaderboards[diff] || [];
    const minTop10 = lb.length >= 10 ? lb[lb.length-1].score : 0;
    if (score > minTop10 || lb.length < 10) {
      showingNameEntry = true;
      pendingScore = score;
      nameInput = '';
      window._nameSubmitted = false;
    } else {
      showingNameEntry = false;
      window._nameSubmitted = false;
    }
    return;
  }

  // Horizontal movement
  moveDir = 0;
  if (keys['arrowleft'] || keys['a']) moveDir = -1;
  if (keys['arrowright'] || keys['d']) moveDir = 1;

  if (touchActive && touchTargetX !== null) {
    const targetNorm = touchTargetX / W;
    const dx = targetNorm - unicorn.x;
    if (Math.abs(dx) > 0.005) {
      unicorn.x += dx * 8 * dt;
    }
  }
  unicorn.x += moveDir * UNICORN_MOVE_SPEED * dt;
  unicorn.x = Math.max(0.05, Math.min(0.95, unicorn.x));

  // Trail
  if (Math.random() < 0.5) {
    const skin = getSkin();
    const trailColor = skin.particleColors[Math.floor(Math.random()*skin.particleColors.length)];
    unicorn.trail.push({ x: unicorn.x * W, y: H * 0.72, life: 1, color: trailColor });
    if (unicorn.trail.length > 25) unicorn.trail.shift();
  }
  unicorn.trail.forEach(t => t.life -= 0.03);
  unicorn.trail = unicorn.trail.filter(t => t.life > 0);

  // Rocket fire trail
  if (activePowerUp && activePowerUp.type === 'rocket') {
    for (let i = 0; i < 3; i++) {
      particles.push({
        x: unicorn.x * W + (Math.random()-0.5)*20,
        y: H * 0.72 + 30,
        vx: (Math.random()-0.5)*2,
        vy: Math.random()*3+1,
        life: 1, decay: 0.04,
        color: Math.random() < 0.5 ? '#ff4400' : '#ffaa00',
        size: Math.random()*6+3,
        type: 'circle',
      });
    }
    shakeAmount = 3;
  }

  // Blink
  unicorn.blinkTimer -= dt;
  if (unicorn.blinkTimer <= 0) unicorn.blinkTimer = 2 + Math.random()*3;

  // --- Collision detection ---
  const viewRange = 600;
  const ux = unicorn.x;
  const unicornScreenY = H * 0.72;
  const unicornScreenX = unicorn.x * W;
  const scaledHitRadius = unicorn.scale;

  // Magnet: pull rainbows and coins toward unicorn
  if (activePowerUp && activePowerUp.type === 'magnet') {
    const magnetRadius = 0.25;
    trackRainbows.forEach((rb, i) => {
      if (collectedSet.has(i)) return;
      const relY = (rb.y - distance) / viewRange;
      if (relY < -0.1 || relY > 1.1) return;
      const dx = unicorn.x - rb.x;
      if (Math.abs(dx) < magnetRadius) rb.x += dx * 3 * dt;
    });
    trackCoins.forEach((c, i) => {
      if (collectedCoins.has(i)) return;
      const relY = (c.y - distance) / viewRange;
      if (relY < -0.1 || relY > 1.1) return;
      const dx = unicorn.x - c.x;
      if (Math.abs(dx) < magnetRadius) c.x += dx * 3 * dt;
    });
  }

  // Rainbow collision
  trackRainbows.forEach((rb, i) => {
    if (collectedSet.has(i)) return;
    const relY = (rb.y - distance) / viewRange;
    if (relY < -0.1 || relY > 1.1) return;

    const screenRbY = H * (1 - relY * 0.85 - 0.08);
    let screenRbX = rb.x * W;
    if (DIFFICULTIES[currentDifficulty].sway) {
      screenRbX += Math.sin(Date.now()/500 + rb.swayOffset) * 40;
    }

    const dx = screenRbX - unicornScreenX;
    const dyScreen = screenRbY - unicornScreenY;
    const dist = Math.sqrt(dx*dx + dyScreen*dyScreen);
    const hm = DIFFICULTIES[currentDifficulty].hitMult;
    const hitRadius = (rb.type === 'big' ? 45 : rb.type === 'gold' ? 40 : 35) * hm * scaledHitRadius;

    if (dist < hitRadius) {
      collectedSet.add(i);
      const mult = getComboMultiplier();
      const pts = Math.round(rb.points * mult);
      score += pts;
      combo++;
      comboTimer = 2.0;
      runStats.totalRainbows++;
      if (rb.type === 'gold') runStats.goldRainbows++;
      if (combo > runStats.maxCombo) runStats.maxCombo = combo;
      
      // Rainbow burst check
      if (combo > 0 && combo % 10 === 0 && combo !== lastBurstCombo) {
        triggerRainbowBurst();
        lastBurstCombo = combo;
      }
      
      unicorn.sparkle = 1;
      playEatSound(rb.points);
      
      const color = rb.type === 'gold' ? '#ffd700' : rb.type === 'big' ? '#ff6b9d' : '#4dc9ff';
      spawnParticles(screenRbX, screenRbY, color, rb.type === 'gold' ? 20 : 10, rb.type === 'gold' ? 5 : 3);
      
      const multText = mult > 1 ? ` x${mult}!` : '';
      addFloatingText(screenRbX, screenRbY - 20, `+${pts}${multText}`, color);
    }
  });

  // Coin collision
  trackCoins.forEach((c, idx) => {
    if (collectedCoins.has(idx)) return;
    const relY = (c.y - distance) / viewRange;
    if (relY < -0.1 || relY > 1.1) return;
    const screenCY = H * (1 - relY * 0.85 - 0.08);
    const screenCX = c.x * W;
    const dx = screenCX - unicornScreenX;
    const dy = screenCY - unicornScreenY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 40 * scaledHitRadius) {
      collectedCoins.add(idx);
      coinsCollectedThisRun++;
      playCoinSound();
      spawnParticles(screenCX, screenCY, '#ffd700', 10, 4);
      addFloatingText(screenCX, screenCY - 20, 'ü™ô +1', '#ffd700');
    }
  });

  // Obstacle collision + near-miss
  trackObstacles.forEach((obs, i) => {
    if (collectedObstacles.has(i)) return;
    const relY = (obs.y - distance) / viewRange;
    if (relY < -0.1 || relY > 1.1) return;

    const screenObsY = H * (1 - relY * 0.85 - 0.08);
    let screenObsX = obs.x * W;

    const dx = screenObsX - unicornScreenX;
    const dyScreen = screenObsY - unicornScreenY;
    const dist = Math.sqrt(dx*dx + dyScreen*dyScreen);
    const hitRadius = obs.type === 'cloud' ? 35 : 25;
    const actualHit = hitRadius * scaledHitRadius;
    const nearMissRadius = actualHit * 1.5;

    if (dist < actualHit) {
      collectedObstacles.add(i);
      if (activePowerUp && activePowerUp.type === 'shield') {
        spawnParticles(screenObsX, screenObsY, '#4dc9ff', 10, 4);
        addFloatingText(screenObsX, screenObsY - 20, 'üõ°Ô∏è Blocked!', '#4dc9ff');
      } else {
        if (gameMode === 'endless') {
          // Lose a life
          endlessLives--;
          lostLifeAnim = 1.0;
          shakeAmount = 12;
          playObstacleHit();
          spawnParticles(screenObsX, screenObsY, '#ff0000', 15, 5);
          addFloatingText(screenObsX, screenObsY - 20, 'üíî -1 LIFE!', '#ff4444');
          if (obs.type === 'cloud') runStats.noCloudHit = false;
          if (endlessLives <= 0) {
            // Game over
            gameState = 'win'; winTime = 0;
            cumulativeScore += score;
            saveCumulativeScore(cumulativeScore);
            const bonusCoins = Math.floor(score / 100);
            coinBalance += coinsCollectedThisRun + bonusCoins;
            saveCoins(coinBalance);
            finalizeMissions();
            for (let j=0;j<5;j++) spawnFirework(Math.random()*W, Math.random()*H*0.5);
            const lb = leaderboards.endless || [];
            const minTop10 = lb.length >= 10 ? lb[lb.length-1].score : 0;
            if (score > minTop10 || lb.length < 10) {
              showingNameEntry = true;
              pendingScore = score;
              nameInput = '';
              window._nameSubmitted = false;
            } else {
              showingNameEntry = false;
              window._nameSubmitted = false;
            }
            return;
          }
        } else {
          slowTimer = obs.slowDuration;
          if (obs.type === 'cloud') runStats.noCloudHit = false;
          playObstacleHit();
          spawnParticles(screenObsX, screenObsY, '#8b00ff', 12, 4);
          shakeAmount = 8;
          addFloatingText(screenObsX, screenObsY - 20, 'SLOW! üí´', '#ff4444');
        }
      }
    } else if (dist < nearMissRadius && !obs.nearMissTriggered) {
      // Near miss!
      obs.nearMissTriggered = true;
      score += 25;
      nearMissFlash = 1.0;
      playNearMiss();
      addFloatingText(screenObsX, screenObsY - 30, 'CLOSE CALL! üò± +25', '#ffff00');
      spawnParticles(screenObsX, screenObsY, '#ffff00', 6, 2);
    }
  });

  // Power-up collision
  trackPowerUps.forEach((pu, i) => {
    if (collectedPowerUps.has(i)) return;
    const relY = (pu.y - distance) / viewRange;
    if (relY < -0.1 || relY > 1.1) return;

    const screenPuY = H * (1 - relY * 0.85 - 0.08);
    let screenPuX = pu.x * W;

    const dx = screenPuX - unicornScreenX;
    const dyScreen = screenPuY - unicornScreenY;
    const dist = Math.sqrt(dx*dx + dyScreen*dyScreen);

    if (dist < 40 * scaledHitRadius) {
      collectedPowerUps.add(i);
      const durations = { magnet: 5, shield: 5, rocket: 3, giant: 4 };
      activePowerUp = { type: pu.type, timeLeft: durations[pu.type] };
      if (pu.type === 'giant') unicorn.scale = 1.1;
      runStats.powerupsUsed++;
      playPowerUp();
      spawnParticles(screenPuX, screenPuY, '#fff', 15, 5);
      const icons = { magnet: 'üß≤', shield: 'üõ°Ô∏è', rocket: 'üöÄ', giant: 'ü¶Ñ' };
      addFloatingText(screenPuX, screenPuY - 30, `${icons[pu.type]} ${pu.type.toUpperCase()}!`, '#fff');
    }
  });

  // Check missed rainbows for combo
  checkMissedRainbows();

  // Check missions
  checkMissions();

  // Combo timer
  if (comboTimer > 0) comboTimer -= dt;
  if (comboBreakEffect > 0) comboBreakEffect -= dt * 2;

  // Floating texts
  floatingTexts.forEach(ft => { ft.y += ft.vy; ft.life -= dt * 0.8; });
  floatingTexts = floatingTexts.filter(ft => ft.life > 0);

  // Particles
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.03; p.life -= p.decay; });
  particles = particles.filter(p => p.life > 0);

  // Sparkle decay
  unicorn.sparkle *= 0.95;

  // Clouds scroll
  bgClouds.forEach(c => {
    c.y += getCurrentSpeed() * dt * 0.3;
    if (c.y > H + 100) { c.y = -100; c.x = Math.random(); }
  });
}

function triggerRainbowBurst() {
  rainbowBurstEffect = 1.0;
  rainbowBurstRadius = 0;
  runStats.rainbowBursts++;
  playRainbowBurst();
  addFloatingText(W/2, H*0.35, 'üåà RAINBOW BURST! üåà', '#fff');
  
  // Collect all visible rainbows
  const viewRange = 600;
  trackRainbows.forEach((rb, i) => {
    if (collectedSet.has(i)) return;
    const relY = (rb.y - distance) / viewRange;
    if (relY < -0.1 || relY > 1.1) return;
    collectedSet.add(i);
    const mult = getComboMultiplier();
    const pts = Math.round(rb.points * mult);
    score += pts;
    runStats.totalRainbows++;
    if (rb.type === 'gold') runStats.goldRainbows++;
    
    const screenRbY = H * (1 - relY * 0.85 - 0.08);
    const screenRbX = rb.x * W;
    spawnParticles(screenRbX, screenRbY, '#ffd700', 5, 3);
  });
  
  // Big particle burst from unicorn
  const ux = unicorn.x * W;
  const uy = H * 0.72;
  const burstColors = ['#ff0000','#ff8800','#ffdd00','#00cc44','#0088ff','#cc44cc'];
  for (let i = 0; i < 40; i++) {
    const angle = (i / 40) * Math.PI * 2;
    const speed = Math.random()*6+3;
    particles.push({
      x: ux, y: uy,
      vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
      life: 1, decay: 0.015,
      color: burstColors[i % burstColors.length],
      size: Math.random()*6+3,
      type: 'circle',
    });
  }
}

// --- Draw Helpers ---
function drawStar(cx, cy, r, points=5, color='#ffd700') {
  ctx.beginPath();
  for (let i = 0; i < points*2; i++) {
    const a = (i * Math.PI / points) - Math.PI/2;
    const rad = i%2===0 ? r : r*0.4;
    if(i===0) ctx.moveTo(cx+Math.cos(a)*rad, cy+Math.sin(a)*rad);
    else ctx.lineTo(cx+Math.cos(a)*rad, cy+Math.sin(a)*rad);
  }
  ctx.closePath(); ctx.fillStyle = color; ctx.fill();
}

function drawCloud(cx, cy, w, alpha) {
  ctx.globalAlpha = alpha;
  ctx.fillStyle = '#fff';
  const h = w*0.4;
  ctx.beginPath(); ctx.ellipse(cx, cy, w*0.5, h*0.4, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx-w*0.2, cy-h*0.15, w*0.3, h*0.35, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx+w*0.15, cy-h*0.2, w*0.25, h*0.3, 0, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;
}

// --- Draw Obstacle ---
function drawObstacle(x, y, obs) {
  ctx.save();
  ctx.translate(x, y);
  
  ctx.globalAlpha = 0.3 + Math.sin(Date.now()/200) * 0.15;
  const warnGrad = ctx.createRadialGradient(0, 0, 5, 0, 0, 45);
  warnGrad.addColorStop(0, 'rgba(255,100,0,0.4)');
  warnGrad.addColorStop(1, 'rgba(255,100,0,0)');
  ctx.fillStyle = warnGrad;
  ctx.beginPath(); ctx.arc(0, 0, 45, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  if (obs.type === 'cloud') {
    ctx.fillStyle = '#3d1a6e';
    ctx.beginPath(); ctx.ellipse(0, 0, 30, 18, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-12, -8, 18, 14, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(10, -6, 16, 12, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.5 + Math.sin(Date.now()/100)*0.5;
    ctx.beginPath(); ctx.moveTo(-5, 10); ctx.lineTo(0, 18); ctx.lineTo(3, 14); ctx.lineTo(7, 22); ctx.stroke();
    ctx.globalAlpha = 0.3 + Math.sin(Date.now()/150+1)*0.3;
    ctx.beginPath(); ctx.moveTo(10, 8); ctx.lineTo(13, 16); ctx.stroke();
    ctx.globalAlpha = 1;
  } else {
    ctx.rotate(Date.now() / 200 + obs.rotation);
    drawStar(0, 0, 18, 5, '#ff4488');
    ctx.fillStyle = '#ff88aa';
    ctx.beginPath(); ctx.arc(0, 0, 7, 0, Math.PI*2); ctx.fill();
  }
  
  ctx.restore();
}

// --- Draw Power-Up ---
function drawPowerUpItem(x, y, pu) {
  ctx.save();
  ctx.translate(x, y);
  
  const t = Date.now() / 300;
  ctx.globalAlpha = 0.4 + Math.sin(t) * 0.2;
  const glowGrad = ctx.createRadialGradient(0, 0, 5, 0, 0, 35);
  glowGrad.addColorStop(0, 'rgba(255,255,255,0.6)');
  glowGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = glowGrad;
  ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  const colors = { magnet: '#ff4444', shield: '#4dc9ff', rocket: '#ff8800', giant: '#c44dff' };
  ctx.fillStyle = colors[pu.type];
  ctx.beginPath(); ctx.roundRect(-16, -16, 32, 32, 8); ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.roundRect(-16, -16, 32, 32, 8); ctx.stroke();

  ctx.font = '18px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const icons = { magnet: 'üß≤', shield: 'üõ°Ô∏è', rocket: 'üöÄ', giant: 'ü¶Ñ' };
  ctx.fillText(icons[pu.type], 0, 1);

  ctx.restore();
}

// --- Draw Coin ---
function drawCoin(x, y) {
  ctx.save();
  ctx.translate(x, y);
  
  const t = Date.now() / 200;
  const scaleX = Math.abs(Math.cos(t)); // spinning effect
  
  // Glow
  ctx.globalAlpha = 0.4;
  const glowGrad = ctx.createRadialGradient(0, 0, 3, 0, 0, 20);
  glowGrad.addColorStop(0, 'rgba(255,215,0,0.6)');
  glowGrad.addColorStop(1, 'rgba(255,215,0,0)');
  ctx.fillStyle = glowGrad;
  ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;
  
  ctx.scale(Math.max(0.2, scaleX), 1);
  
  // Gold circle
  ctx.fillStyle = '#ffd700';
  ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#daa520';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); ctx.stroke();
  
  // Inner detail
  ctx.fillStyle = '#ffec80';
  ctx.beginPath(); ctx.arc(0, 0, 7, 0, Math.PI*2); ctx.fill();
  
  if (scaleX > 0.3) {
    ctx.fillStyle = '#daa520';
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('¬¢', 0, 1);
  }
  
  ctx.restore();
}

// --- Draw Unicorn ---
function drawUnicorn(x, y, sparkle) {
  ctx.save();
  ctx.translate(x, y);
  const sc = (1 + sparkle*0.1) * unicorn.scale;
  ctx.scale(sc, sc);

  const skin = getSkin();
  let bodyColor = skin.bodyColor;
  if (bodyColor === 'rainbow') {
    const hue = (Date.now() / 10) % 360;
    bodyColor = `hsl(${hue}, 100%, 80%)`;
  }

  // Shield aura
  if (activePowerUp && activePowerUp.type === 'shield') {
    ctx.globalAlpha = 0.3 + Math.sin(Date.now()/200) * 0.15;
    const shieldGrad = ctx.createRadialGradient(0, 0, 20, 0, 0, 50);
    shieldGrad.addColorStop(0, 'rgba(77,201,255,0.3)');
    shieldGrad.addColorStop(1, 'rgba(77,201,255,0)');
    ctx.fillStyle = shieldGrad;
    ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(77,201,255,0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI*2); ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // Glow
  if (sparkle > 0.1) {
    const grad = ctx.createRadialGradient(0, 0, 10, 0, 0, 50);
    grad.addColorStop(0, `rgba(255,107,157,${sparkle*0.4})`);
    grad.addColorStop(1, 'rgba(255,107,157,0)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI*2); ctx.fill();
  }

  // Body
  ctx.fillStyle = bodyColor;
  ctx.strokeStyle = skin.strokeColor;
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.ellipse(0, 8, 20, 16, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();

  // Head
  ctx.fillStyle = bodyColor;
  ctx.beginPath(); ctx.ellipse(0, -12, 14, 12, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();

  // Diamond sparkles
  if (skin.id === 'diamond') {
    for (let i = 0; i < 5; i++) {
      const sx = Math.sin(Date.now()/300 + i*1.3) * 12;
      const sy = Math.cos(Date.now()/400 + i*1.7) * 10;
      ctx.globalAlpha = 0.5 + Math.sin(Date.now()/200 + i) * 0.3;
      drawStar(sx, sy, 3, 4, '#e0f0ff');
    }
    ctx.globalAlpha = 1;
  }

  // Galaxy stars
  if (skin.id === 'galaxy') {
    for (let i = 0; i < 6; i++) {
      const sx = Math.sin(i*1.1) * 14;
      const sy = Math.cos(i*1.1) * 10 + 2;
      ctx.globalAlpha = 0.4 + Math.sin(Date.now()/250 + i*2) * 0.4;
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(sx, sy, 1.5, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Horn
  ctx.fillStyle = '#ffd700';
  ctx.beginPath(); ctx.moveTo(0, -32); ctx.lineTo(-5, -18); ctx.lineTo(5, -18); ctx.closePath(); ctx.fill();
  ctx.strokeStyle = '#ffec80'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(-2, -28); ctx.lineTo(2, -25); ctx.moveTo(-1, -23); ctx.lineTo(3, -21); ctx.stroke();

  // Ears
  ctx.fillStyle = '#ffe0f0';
  ctx.beginPath(); ctx.moveTo(-8, -18); ctx.lineTo(-12, -28); ctx.lineTo(-4, -19); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(8, -18); ctx.lineTo(12, -28); ctx.lineTo(4, -19); ctx.closePath(); ctx.fill();

  // Eyes
  const blinking = unicorn.blinkTimer < 0.15;
  if (blinking) {
    ctx.strokeStyle = '#2d1b4e'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-7, -13); ctx.lineTo(-3, -13); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(3, -13); ctx.lineTo(7, -13); ctx.stroke();
  } else {
    ctx.fillStyle = '#2d1b4e';
    ctx.beginPath(); ctx.arc(-5, -13, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(5, -13, 3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(-4, -14, 1.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(6, -14, 1.2, 0, Math.PI*2); ctx.fill();
  }

  // Blush
  ctx.fillStyle = 'rgba(255,150,180,0.4)';
  ctx.beginPath(); ctx.ellipse(-9, -8, 4, 2.5, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(9, -8, 4, 2.5, 0, 0, Math.PI*2); ctx.fill();

  // Smile
  ctx.strokeStyle = '#c77dba'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(0, -7, 5, 0.3, Math.PI-0.3); ctx.stroke();

  // Mane
  const maneColors = ['#ff6b9d','#ff9e4d','#ffd700','#4dff88','#4dc9ff','#c44dff'];
  maneColors.forEach((c, i) => {
    ctx.fillStyle = c; ctx.globalAlpha = 0.8;
    const mx = -12 + i*1.5 + Math.sin(Date.now()/200 + i)*2;
    const my = -5 + i*3;
    ctx.beginPath(); ctx.ellipse(mx, my, 5, 3.5, -0.3+i*0.15, 0, Math.PI*2); ctx.fill();
    const mx2 = 12 - i*1.5 + Math.sin(Date.now()/200 + i + 3)*2;
    ctx.beginPath(); ctx.ellipse(mx2, my, 5, 3.5, 0.3-i*0.15, 0, Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Tail
  maneColors.forEach((c, i) => {
    ctx.strokeStyle = c; ctx.lineWidth = 3; ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.moveTo(Math.sin(i)*3, 22);
    ctx.quadraticCurveTo(Math.sin(Date.now()/250+i)*8, 28+i*3, Math.sin(Date.now()/300+i*0.7)*10, 35+i*4);
    ctx.stroke();
  });
  ctx.globalAlpha = 1;

  // Legs
  ctx.strokeStyle = skin.strokeColor; ctx.lineWidth = 4; ctx.lineCap = 'round';
  const legBob = Math.sin(Date.now()/120)*4;
  [[-9,20,legBob],[9,20,-legBob],[-5,20,-legBob],[5,20,legBob]].forEach(([lx,ly,bob]) => {
    ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx+bob*0.3, ly+10); ctx.stroke();
    ctx.fillStyle = '#ddc0f0';
    ctx.beginPath(); ctx.arc(lx+bob*0.3, ly+11, 3, 0, Math.PI*2); ctx.fill();
  });

  ctx.restore();
}

// --- Draw Ghost Unicorn ---
function drawGhostUnicorn(x, y) {
  ctx.save();
  ctx.translate(x, y);
  ctx.globalAlpha = 0.2;
  ctx.scale(0.85, 0.85);
  
  // Simple body
  ctx.fillStyle = '#aaa';
  ctx.beginPath(); ctx.ellipse(0, 8, 20, 16, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(0, -12, 14, 12, 0, 0, Math.PI*2); ctx.fill();
  
  // Horn
  ctx.fillStyle = '#ccc';
  ctx.beginPath(); ctx.moveTo(0, -32); ctx.lineTo(-5, -18); ctx.lineTo(5, -18); ctx.closePath(); ctx.fill();
  
  // PB label
  ctx.globalAlpha = 0.4;
  ctx.fillStyle = '#ffd700';
  ctx.font = 'bold 10px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('PB', 0, -38);
  
  ctx.restore();
}

// --- Draw Rainbow Collectible ---
function drawRainbow(x, y, type) {
  ctx.save();
  ctx.translate(x, y);
  const r = type === 'big' ? 28 : type === 'gold' ? 24 : 18;

  const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r*2);
  grad.addColorStop(0, 'rgba(255,200,255,0.25)');
  grad.addColorStop(1, 'rgba(255,200,255,0)');
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(0, -r*0.2, r*2, 0, Math.PI*2); ctx.fill();

  if (type === 'gold') {
    const goldColors = ['#fff8dc','#ffd700','#ffb800','#ff9500','#ffd700','#fff8dc'];
    ctx.lineCap = 'round';
    goldColors.forEach((c, i) => {
      const arcR = r - i*2.5; if (arcR <= 0) return;
      ctx.strokeStyle = c; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(0, r*0.3, arcR, Math.PI, 0); ctx.stroke();
    });
    for (let i = 0; i < 5; i++) {
      const a = Math.PI + (i/4)*Math.PI;
      const sr = r - 6;
      ctx.globalAlpha = 0.4 + Math.sin(Date.now()/200+i*1.5)*0.4;
      drawStar(Math.cos(a)*sr, r*0.3+Math.sin(a)*sr, 4, 4, '#fff');
    }
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#ffd700'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('100', 0, r*0.3 + r + 12);
  } else {
    const rainbowColors = ['#ff0000','#ff8800','#ffdd00','#00cc44','#0088ff','#8844ff','#cc44cc'];
    ctx.lineCap = 'round';
    const lineW = type === 'big' ? 3 : 2;
    rainbowColors.forEach((c, i) => {
      const arcR = r - i*(type==='big'?2.8:2); if (arcR <= 2) return;
      ctx.strokeStyle = c; ctx.lineWidth = lineW;
      ctx.beginPath(); ctx.arc(0, r*0.3, arcR, Math.PI, 0); ctx.stroke();
    });
    ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.7;
    ctx.beginPath(); ctx.ellipse(-r+2, r*0.3, 5, 3, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r-2, r*0.3, 5, 3, 0, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = type === 'big' ? '#ff6b9d' : '#4dc9ff';
    ctx.font = `bold ${type==='big'?12:10}px sans-serif`; ctx.textAlign = 'center';
    ctx.fillText(type === 'big' ? '50' : '10', 0, r*0.3 + r + 10);
  }
  ctx.restore();
}

// --- Draw Finish Rainbow ---
function drawFinishRainbow(y) {
  ctx.save();
  ctx.translate(W/2, y);
  const r = W * 0.4;
  const rainbowColors = ['#ff0000','#ff8800','#ffdd00','#00cc44','#0088ff','#8844ff','#cc44cc'];
  ctx.lineCap = 'round';
  rainbowColors.forEach((c, i) => {
    const arcR = r - i*8; if (arcR <= 0) return;
    ctx.strokeStyle = c; ctx.lineWidth = 8;
    ctx.beginPath(); ctx.arc(0, 0, arcR, Math.PI, 0); ctx.stroke();
  });
  for (let i = 0; i < 12; i++) {
    const a = Math.PI + (i/11)*Math.PI;
    ctx.globalAlpha = 0.5 + Math.sin(Date.now()/200+i)*0.4;
    drawStar(Math.cos(a)*(r+15), Math.sin(a)*(r+15), 6, 5, '#ffd700');
  }
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#ffd700'; ctx.font = `bold ${Math.min(24,W*0.05)}px sans-serif`; ctx.textAlign = 'center';
  ctx.fillText('üåà FINISH! üåà', 0, -r - 15);
  ctx.restore();
}

// --- Draw Background ---
function drawPlayBackground() {
  const TL = gameMode === 'endless' ? Math.max(10000, distance + 5000) : currentTrackLength;
  const progress = distance / TL;
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  const r1 = Math.floor(20 + progress*50);
  const g1 = Math.floor(8 + progress*30);
  const b1 = Math.floor(50 + progress*60);
  const r2 = Math.floor(40 + progress*80);
  const g2 = Math.floor(15 + progress*50);
  const b2 = Math.floor(80 + progress*70);
  grad.addColorStop(0, `rgb(${Math.min(r1,255)},${Math.min(g1,255)},${Math.min(b1,255)})`);
  grad.addColorStop(1, `rgb(${Math.min(r2,255)},${Math.min(g2,255)},${Math.min(b2,255)})`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  const viewRange = 600;
  trackStars.forEach(s => {
    const relY = (s.y - distance) / viewRange;
    if (relY < -0.1 || relY > 1.2) return;
    const sy = H * (1 - relY * 0.85 - 0.08);
    const sx = s.x * W;
    const alpha = 0.3 + Math.sin(Date.now()*0.003 + s.twinkleOffset)*0.3;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#fff';
    if (s.size > 1.5) drawStar(sx, sy, s.size, 4, '#fff');
    else { ctx.beginPath(); ctx.arc(sx, sy, s.size, 0, Math.PI*2); ctx.fill(); }
  });
  ctx.globalAlpha = 1;

  bgClouds.forEach(c => drawCloud(c.x * W, c.y, c.w, c.alpha));

  const laneW = W * 0.5;
  const curveAggr = gameMode === 'endless' ? Math.min(3, 1 + distance / 50000) : 1;
  for (let sy = 0; sy < H; sy += 4) {
    const trackY = distance + ((H - sy) / H) * viewRange;
    const offset = getLaneCenterOffset(trackY, curveAggr);
    const centerX = (0.5 + offset) * W;
    const alpha = 0.04;
    const rainbowPos = (sy / H + Date.now() * 0.0001) % 1;
    const hue = rainbowPos * 360;
    ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${alpha})`;
    ctx.fillRect(centerX - laneW/2, sy, laneW, 5);
  }

  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 20]);
  ctx.beginPath();
  for (let sy = 0; sy < H; sy += 2) {
    const trackY = distance + ((H - sy) / H) * viewRange;
    const offset = getLaneCenterOffset(trackY, curveAggr);
    const centerX = (0.5 + offset) * W;
    if (sy === 0) ctx.moveTo(centerX - laneW/2, sy);
    else ctx.lineTo(centerX - laneW/2, sy);
  }
  ctx.stroke();
  ctx.beginPath();
  for (let sy = 0; sy < H; sy += 2) {
    const trackY = distance + ((H - sy) / H) * viewRange;
    const offset = getLaneCenterOffset(trackY, curveAggr);
    const centerX = (0.5 + offset) * W;
    if (sy === 0) ctx.moveTo(centerX + laneW/2, sy);
    else ctx.lineTo(centerX + laneW/2, sy);
  }
  ctx.stroke();
  ctx.setLineDash([]);

  if (sprintActive && gameMode === 'race') {
    const intensity = 0.15 + Math.sin(Date.now()/200) * 0.1;
    const edgeGrad = ctx.createLinearGradient(0, 0, W*0.15, 0);
    edgeGrad.addColorStop(0, `rgba(255,80,0,${intensity})`);
    edgeGrad.addColorStop(1, 'rgba(255,80,0,0)');
    ctx.fillStyle = edgeGrad;
    ctx.fillRect(0, 0, W*0.15, H);
    const edgeGrad2 = ctx.createLinearGradient(W, 0, W*0.85, 0);
    edgeGrad2.addColorStop(0, `rgba(255,80,0,${intensity})`);
    edgeGrad2.addColorStop(1, 'rgba(255,80,0,0)');
    ctx.fillStyle = edgeGrad2;
    ctx.fillRect(W*0.85, 0, W*0.15, H);
  }

  // Near-miss yellow flash
  if (nearMissFlash > 0) {
    ctx.globalAlpha = nearMissFlash * 0.3;
    ctx.fillStyle = '#ffff00';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  // Rainbow burst shockwave
  if (rainbowBurstEffect > 0) {
    ctx.globalAlpha = rainbowBurstEffect * 0.4;
    const ux = unicorn.x * W;
    const uy = H * 0.72;
    const burstColors = ['#ff0000','#ff8800','#ffdd00','#00cc44','#0088ff','#cc44cc'];
    for (let i = 0; i < 6; i++) {
      ctx.strokeStyle = burstColors[i];
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(ux, uy, rainbowBurstRadius + i * 5, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }
}

// --- Draw HUD ---
function drawHUD() {
  const TL = gameMode === 'endless' ? 1 : currentTrackLength;
  const progress = gameMode === 'endless' ? 0 : distance / TL;
  const diff = DIFFICULTIES[currentDifficulty];

  // Difficulty + mode label
  ctx.fillStyle = diff.color;
  ctx.font = `bold ${Math.min(13, W*0.025)}px sans-serif`;
  ctx.textAlign = 'left';
  const dailyTag = isDailyChallenge ? ' üìÖ' : '';
  const modeTag = gameMode === 'endless' ? '‚ôæÔ∏è Endless' : `${diff.emoji} ${diff.label}`;
  ctx.fillText(`${modeTag}${dailyTag}`, 15, 18);

  // Score
  ctx.fillStyle = '#ffd700';
  ctx.font = `bold ${Math.min(22, W*0.04)}px sans-serif`;
  ctx.textAlign = 'left';
  ctx.fillText(`‚ú® ${score}`, 15, 42);

  // Coins collected this run
  if (coinsCollectedThisRun > 0) {
    ctx.fillStyle = '#ffd700';
    ctx.font = `bold ${Math.min(13, W*0.025)}px sans-serif`;
    ctx.fillText(`ü™ô ${coinsCollectedThisRun}`, 15 + Math.min(22,W*0.04) * 4, 42);
  }

  // Endless mode: distance + lives
  if (gameMode === 'endless') {
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.min(14, W*0.028)}px sans-serif`;
    ctx.textAlign = 'right';
    ctx.fillText(`üìè ${Math.floor(distance)}m`, W - 15, 18);
    
    // Lives (hearts)
    ctx.textAlign = 'right';
    ctx.font = `${Math.min(20, W*0.04)}px sans-serif`;
    let heartsStr = '';
    for (let i = 0; i < endlessLives; i++) heartsStr += '‚ù§Ô∏è';
    for (let i = endlessLives; i < (activeBoosts.extralife ? 4 : 3); i++) heartsStr += 'üñ§';
    // Animate lost life
    if (lostLifeAnim > 0) {
      ctx.globalAlpha = 0.5 + Math.sin(Date.now()/50) * 0.5;
    }
    ctx.fillText(heartsStr, W - 15, 42);
    ctx.globalAlpha = 1;

    // Level
    ctx.fillStyle = '#c9a0ff';
    ctx.font = `bold ${Math.min(12, W*0.024)}px sans-serif`;
    ctx.textAlign = 'right';
    ctx.fillText(`Level ${endlessLevel}`, W - 15, 58);

    // Level up flash
    if (endlessLevelUpFlash > 0) {
      ctx.globalAlpha = Math.min(1, endlessLevelUpFlash);
      ctx.fillStyle = '#4dff88';
      ctx.font = `bold ${Math.min(36, W*0.06)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText('‚¨ÜÔ∏è LEVEL UP! ‚¨ÜÔ∏è', W/2, H*0.3);
      ctx.globalAlpha = 1;
    }
  }

  // Combo display
  if (combo >= 3 && comboTimer > 0) {
    const comboSize = Math.min(28, W*0.05);
    const mult = getComboMultiplier();
    ctx.fillStyle = combo >= 10 ? '#ff0000' : combo >= 6 ? '#ff8800' : '#ffd700';
    ctx.font = `bold ${comboSize}px sans-serif`;
    ctx.textAlign = 'center';
    const pulseScale = 1 + Math.sin(Date.now()/100) * 0.1;
    ctx.save();
    ctx.translate(W/2, 35);
    ctx.scale(pulseScale, pulseScale);
    ctx.fillText(`${combo}x COMBO! üî•`, 0, 0);
    ctx.font = `bold ${comboSize * 0.6}px sans-serif`;
    ctx.fillText(`${mult}x multiplier`, 0, comboSize * 0.8);
    ctx.restore();
  }

  // Combo break effect
  if (comboBreakEffect > 0) {
    ctx.globalAlpha = comboBreakEffect;
    ctx.fillStyle = '#ff0000';
    ctx.font = `bold ${Math.min(24, W*0.04)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText('COMBO BREAK! üíî', W/2, 70);
    ctx.globalAlpha = 1;
  }

  // Active power-up
  let puY = 62;
  if (activePowerUp) {
    const icons = { magnet: 'üß≤', shield: 'üõ°Ô∏è', rocket: 'üöÄ', giant: 'ü¶Ñ' };
    const puX = 15;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath(); ctx.roundRect(puX, puY, 120, 28, 8); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.min(15, W*0.03)}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.fillText(`${icons[activePowerUp.type]} ${activePowerUp.type.toUpperCase()}`, puX+6, puY+14);
    const maxDur = { magnet: 5, shield: 5, rocket: 3, giant: 4 }[activePowerUp.type];
    const frac = activePowerUp.timeLeft / maxDur;
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(puX+6, puY+20, 108, 4);
    ctx.fillStyle = '#4dff88';
    ctx.fillRect(puX+6, puY+20, 108*frac, 4);
    puY += 32;
  }

  // Active boosts display
  const boostIcons = [];
  if (activeBoosts.scoreboost) boostIcons.push('‚≠ê1.5x');
  if (activeBoosts.headstart) boostIcons.push('üöÄStart');
  if (boostIcons.length > 0) {
    ctx.fillStyle = '#c9a0ff';
    ctx.font = `bold ${Math.min(10, W*0.02)}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.fillText(boostIcons.join(' | '), 15, puY + 12);
    puY += 16;
  }

  // Speed indicator
  const speedPct = Math.round((getCurrentSpeed() / getBaseSpeed()) * 100);
  ctx.fillStyle = slowTimer > 0 ? '#ff4444' : sprintActive ? '#ff8800' : '#aaa';
  ctx.font = `bold ${Math.min(12, W*0.024)}px sans-serif`;
  ctx.textAlign = 'left';
  ctx.fillText(`‚ö° ${speedPct}%`, 15, puY + 12);

  // Sprint flash
  if (sprintFlashTimer > 0 && gameMode === 'race') {
    ctx.globalAlpha = Math.min(1, sprintFlashTimer);
    ctx.fillStyle = '#ff4400';
    ctx.font = `bold ${Math.min(36, W*0.06)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText('üî• SPRINT! üî•', W/2, H*0.4);
    ctx.globalAlpha = 1;
  }

  // Slow indicator
  if (slowTimer > 0) {
    ctx.fillStyle = 'rgba(100,0,150,0.3)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#ff4444';
    ctx.font = `bold ${Math.min(20, W*0.035)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText('üí´ SLOWED! üí´', W/2, H * 0.55);
  }

  // Mission complete display
  if (missionCompleteDisplayTimer > 0) {
    ctx.globalAlpha = Math.min(1, missionCompleteDisplayTimer);
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath(); ctx.roundRect(W/2 - 150, H*0.45 - 20, 300, 50, 12); ctx.fill();
    ctx.fillStyle = '#ffd700';
    ctx.font = `bold ${Math.min(16, W*0.03)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText('MISSION COMPLETE! üéØ +25 ü™ô', W/2, H*0.45 + 10);
    ctx.globalAlpha = 1;
  }

  // Progress bar (right side, vertical) ‚Äî race mode only
  if (gameMode === 'race') {
    const barH = H * 0.6;
    const barW = 18;
    const barX = W - 35;
    const barY = (H - barH) / 2;

    ctx.save();
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.min(11, W*0.022)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.translate(barX + barW/2, barY - 15);
    ctx.fillText('üåà', 0, 0);
    ctx.restore();

    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath(); ctx.roundRect(barX, barY, barW, barH, barW/2); ctx.fill();

    if (progress > 0) {
      const fillH = barH * progress;
      const fGrad = ctx.createLinearGradient(0, barY+barH, 0, barY+barH-fillH);
      fGrad.addColorStop(0, '#ff6b9d');
      fGrad.addColorStop(0.2, '#ff9e4d');
      fGrad.addColorStop(0.4, '#ffd700');
      fGrad.addColorStop(0.6, '#4dff88');
      fGrad.addColorStop(0.8, '#4dc9ff');
      fGrad.addColorStop(1, '#c44dff');
      ctx.fillStyle = fGrad;
      ctx.beginPath();
      ctx.roundRect(barX+2, barY+barH-fillH, barW-4, fillH, (barW-4)/2);
      ctx.fill();
    }

    const indicatorY = barY + barH - barH * progress;
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('ü¶Ñ', barX + barW/2 - 16, indicatorY + 5);
    ctx.fillText('üåà', barX + barW/2, barY + barH + 18);

    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.min(12, W*0.024)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(`${Math.floor(progress*100)}%`, barX + barW/2, barY + barH + 32);
  }

  // Touch indicators
  if (gameState === 'playing') {
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.min(30, W*0.06)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText('‚óÄ', W*0.12, H*0.5);
    ctx.fillText('‚ñ∂', W*0.88, H*0.5);
    ctx.globalAlpha = 1;
  }

  // Floating texts
  floatingTexts.forEach(ft => {
    ctx.globalAlpha = ft.life;
    ctx.fillStyle = ft.color;
    ctx.font = `bold ${Math.min(18, W*0.035)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(ft.text, ft.x, ft.y);
  });
  ctx.globalAlpha = 1;
}

// --- Draw Title ---
function drawTitle() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a0a2e'); grad.addColorStop(1, '#2d1050');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);

  const t = titleTime;
  ctx.textAlign = 'center';

  const titleSize = Math.min(26, W*0.045);
  const instrSize = Math.min(13, W*0.026);
  const instrSpacing = Math.min(20, H*0.028);
  const btnH = Math.min(46, H*0.058);

  // Apply scroll
  ctx.save();
  ctx.translate(0, -titleScrollY);

  let y = Math.max(10, H * 0.02);

  // Coin display top right
  ctx.fillStyle = '#ffd700';
  ctx.font = `bold ${Math.min(14, W*0.028)}px sans-serif`;
  ctx.textAlign = 'right';
  ctx.fillText(`ü™ô ${coinBalance}`, W - 15, y + 18);
  ctx.textAlign = 'center';

  // Unicorn emoji
  ctx.font = `${36+Math.sin(t*2)*3}px sans-serif`;
  ctx.fillText('ü¶Ñ', W/2, y + 28);
  y += 38;

  // Title
  const title = 'Eating Unicorn Rainbows';
  ctx.font = `bold ${titleSize}px sans-serif`;
  const colors = ['#ff6b9d','#ff9e4d','#ffd700','#4dff88','#4dc9ff','#c44dff'];
  const metrics = ctx.measureText(title);
  const startX = W/2 - metrics.width/2;
  for (let i = 0; i < title.length; i++) {
    ctx.fillStyle = colors[Math.floor((i+t*3)%colors.length)];
    const charW = ctx.measureText(title[i]).width;
    const yOff = Math.sin(t*3+i*0.3)*3;
    ctx.fillText(title[i], startX+ctx.measureText(title.substring(0,i)).width+charW/2, y+titleSize+yOff);
  }
  y += titleSize + 24;

  // Instructions
  const instructions = [
    { icon: 'üëÜ', text: 'Drag to move! Collect rainbows!', color: '#4dc9ff' },
    { icon: '‚ö°', text: 'Dodge clouds & stars!', color: '#ff6b9d' },
    { icon: 'üî•', text: 'Chain combos for multipliers!', color: '#ffd700' },
  ];
  instructions.forEach((inst, i) => {
    const fadeStart = 0.3 + i*0.3;
    const alpha = Math.min(1, Math.max(0, (t-fadeStart)*2));
    ctx.globalAlpha = alpha;
    ctx.font = `bold ${instrSize}px sans-serif`;
    ctx.fillStyle = inst.color;
    ctx.fillText(`${inst.icon} ${inst.text}`, W/2, y + i*instrSpacing);
  });
  ctx.globalAlpha = 1;
  y += instructions.length * instrSpacing + 18;

  // Skin selector
  ctx.fillStyle = '#c9a0ff';
  ctx.font = `bold ${Math.min(12, W*0.024)}px sans-serif`;
  ctx.fillText('ü¶Ñ Select Skin', W/2, y);
  y += 8;

  const skinSize = Math.min(32, W * 0.06);
  const skinGap = 6;
  const totalSkinW = SKINS.length * (skinSize + skinGap) - skinGap;
  const skinStartX = (W - totalSkinW) / 2;
  _skinBtns = [];

  SKINS.forEach((skin, i) => {
    const sx = skinStartX + i * (skinSize + skinGap);
    const sy = y;
    _skinBtns.push({ x: sx, y: sy, w: skinSize, h: skinSize, skin });

    const unlocked = isSkinUnlocked(skin);
    const selected = selectedSkin === skin.id;

    if (selected) {
      ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(sx + skinSize/2, sy + skinSize/2, skinSize/2 + 2, 0, Math.PI*2); ctx.stroke();
    }

    if (unlocked) {
      let color = skin.bodyColor;
      if (color === 'rainbow') {
        const hue = (Date.now()/10 + i*60) % 360;
        color = `hsl(${hue}, 100%, 80%)`;
      }
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(sx + skinSize/2, sy + skinSize/2, skinSize/2 - 2, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = skin.strokeColor; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(sx + skinSize/2, sy + skinSize/2, skinSize/2 - 2, 0, Math.PI*2); ctx.stroke();
    } else {
      ctx.fillStyle = '#333';
      ctx.beginPath(); ctx.arc(sx + skinSize/2, sy + skinSize/2, skinSize/2 - 2, 0, Math.PI*2); ctx.fill();
      ctx.font = `${skinSize*0.4}px sans-serif`;
      ctx.fillStyle = '#666';
      ctx.fillText('üîí', sx + skinSize/2, sy + skinSize/2 + skinSize*0.15);
    }
  });
  y += skinSize + 6;

  const nextSkin = SKINS.find(s => !isSkinUnlocked(s));
  if (nextSkin) {
    ctx.fillStyle = '#888';
    ctx.font = `${Math.min(10, W*0.02)}px sans-serif`;
    ctx.fillText(`Total: ${cumulativeScore} pts ‚Äî Next: ${nextSkin.name} at ${nextSkin.threshold}`, W/2, y + 10);
  } else {
    ctx.fillStyle = '#ffd700';
    ctx.font = `${Math.min(10, W*0.02)}px sans-serif`;
    ctx.fillText(`All skins unlocked! Total: ${cumulativeScore} pts ‚≠ê`, W/2, y + 10);
  }
  y += 28;

  // Difficulty buttons
  ctx.fillStyle = '#c9a0ff';
  ctx.font = `bold ${Math.min(13,W*0.026)}px sans-serif`;
  ctx.fillText('üåü Pick difficulty! üåü', W/2, y);
  y += 18;

  const btnY = y;
  const btnGap = 6;
  const totalBtnW = Math.min(W*0.92, 520);
  const singleBtnW = (totalBtnW - btnGap*(DIFFICULTY_ORDER.length-1)) / DIFFICULTY_ORDER.length;
  const btnStartX = (W - totalBtnW) / 2;

  _diffBtns = [];
  DIFFICULTY_ORDER.forEach((key, idx) => {
    const d = DIFFICULTIES[key];
    const bx = btnStartX + idx * (singleBtnW + btnGap);
    const by = btnY;
    _diffBtns.push({ x: bx, y: by, w: singleBtnW, h: btnH, key });

    if (key === 'crazy') {
      const hue = (Date.now()/10 + idx*60) % 360;
      ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
    } else {
      ctx.fillStyle = d.bg;
    }
    ctx.shadowColor = d.color; ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.roundRect(bx, by, singleBtnW, btnH, 10); ctx.fill();
    ctx.shadowBlur = 0;

    if (key === currentDifficulty) {
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.roundRect(bx, by, singleBtnW, btnH, 10); ctx.stroke();
    }

    ctx.fillStyle = '#fff';
    const labelSize = Math.min(10, singleBtnW*0.2);
    ctx.font = `bold ${labelSize}px sans-serif`;
    ctx.fillText(d.emoji, bx+singleBtnW/2, by+btnH*0.38);
    ctx.font = `bold ${Math.max(7, labelSize-1)}px sans-serif`;
    ctx.fillText(d.label, bx+singleBtnW/2, by+btnH*0.72);
  });

  // START + Daily + Endless buttons
  const rowBtnW = Math.min(120, W*0.28);
  const rowBtnH = Math.min(46, H*0.058);
  const totalRowW = rowBtnW * 3 + 16;
  const rowStartX = (W - totalRowW) / 2;
  const rowY = btnY + btnH + 20;

  // START
  _startBtn = { x: rowStartX, y: rowY, w: rowBtnW, h: rowBtnH };
  const pulse = 0.8 + Math.sin(t*3)*0.2;
  ctx.shadowColor = '#4dff88'; ctx.shadowBlur = 15 * pulse;
  const startGrad = ctx.createLinearGradient(rowStartX, rowY, rowStartX+rowBtnW, rowY);
  startGrad.addColorStop(0, '#4dff88'); startGrad.addColorStop(1, '#00cc66');
  ctx.fillStyle = startGrad;
  ctx.beginPath(); ctx.roundRect(rowStartX, rowY, rowBtnW, rowBtnH, rowBtnH/2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.min(15, W*0.03)}px sans-serif`;
  ctx.fillText('üèÅ START', rowStartX + rowBtnW/2, rowY + rowBtnH*0.65);

  // DAILY
  const dailyX = rowStartX + rowBtnW + 8;
  _dailyBtn = { x: dailyX, y: rowY, w: rowBtnW, h: rowBtnH };
  ctx.shadowColor = '#ff9e4d'; ctx.shadowBlur = 12 * pulse;
  const dailyGrad = ctx.createLinearGradient(dailyX, rowY, dailyX+rowBtnW, rowY);
  dailyGrad.addColorStop(0, '#ff9e4d'); dailyGrad.addColorStop(1, '#ff6b35');
  ctx.fillStyle = dailyGrad;
  ctx.beginPath(); ctx.roundRect(dailyX, rowY, rowBtnW, rowBtnH, rowBtnH/2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.min(15, W*0.03)}px sans-serif`;
  ctx.fillText('üìÖ DAILY', dailyX + rowBtnW/2, rowY + rowBtnH*0.65);

  // ENDLESS ‚Äî disabled for now
  _endlessBtn = null;
  if (false) {
  const endlessX = dailyX + rowBtnW + 8;
  _endlessBtn = { x: endlessX, y: rowY, w: rowBtnW, h: rowBtnH };
  ctx.shadowColor = '#c44dff'; ctx.shadowBlur = 15 * pulse;
  const endlessGrad = ctx.createLinearGradient(endlessX, rowY, endlessX+rowBtnW, rowY);
  endlessGrad.addColorStop(0, '#c44dff'); endlessGrad.addColorStop(1, '#8b00ff');
  ctx.fillStyle = endlessGrad;
  ctx.beginPath(); ctx.roundRect(endlessX, rowY, rowBtnW, rowBtnH, rowBtnH/2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.min(15, W*0.03)}px sans-serif`;
  ctx.fillText('‚ôæÔ∏è ENDLESS', endlessX + rowBtnW/2, rowY + rowBtnH*0.65);
  } // end disabled endless

  // Make START and DAILY wider and centered without endless
  const startDailyW = Math.min(160, W*0.38);
  const startDailyTotalW = startDailyW * 2 + 12;
  const sdStartX = (W - startDailyTotalW) / 2;
  
  // Reposition START
  _startBtn = { x: sdStartX, y: rowY, w: startDailyW, h: rowBtnH };
  ctx.clearRect(rowStartX, rowY, totalRowW, rowBtnH);
  // Redraw bg
  const bgGrad2 = ctx.createLinearGradient(0, 0, 0, H);
  bgGrad2.addColorStop(0, '#1a0a2e'); bgGrad2.addColorStop(1, '#2d1050');
  ctx.fillStyle = bgGrad2; ctx.fillRect(sdStartX - 5, rowY - 2, startDailyTotalW + 10, rowBtnH + 4);
  
  ctx.shadowColor = '#4dff88'; ctx.shadowBlur = 15 * pulse;
  const sg2 = ctx.createLinearGradient(sdStartX, rowY, sdStartX+startDailyW, rowY);
  sg2.addColorStop(0, '#4dff88'); sg2.addColorStop(1, '#00cc66');
  ctx.fillStyle = sg2;
  ctx.beginPath(); ctx.roundRect(sdStartX, rowY, startDailyW, rowBtnH, rowBtnH/2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.min(16, W*0.035)}px sans-serif`;
  ctx.fillText('üèÅ START', sdStartX + startDailyW/2, rowY + rowBtnH*0.65);

  // Reposition DAILY
  const dailyX2 = sdStartX + startDailyW + 12;
  _dailyBtn = { x: dailyX2, y: rowY, w: startDailyW, h: rowBtnH };
  ctx.shadowColor = '#ff9e4d'; ctx.shadowBlur = 12 * pulse;
  const dg2 = ctx.createLinearGradient(dailyX2, rowY, dailyX2+startDailyW, rowY);
  dg2.addColorStop(0, '#ff9e4d'); dg2.addColorStop(1, '#ff6b35');
  ctx.fillStyle = dg2;
  ctx.beginPath(); ctx.roundRect(dailyX2, rowY, startDailyW, rowBtnH, rowBtnH/2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.min(16, W*0.035)}px sans-serif`;
  ctx.fillText('üìÖ DAILY', dailyX2 + startDailyW/2, rowY + rowBtnH*0.65);

  // Shop button
  const shopBtnW = Math.min(100, W*0.25);
  const shopBtnX = (W - shopBtnW) / 2;
  const shopBtnY = rowY + rowBtnH + 20;
  _shopBtn = { x: shopBtnX, y: shopBtnY, w: shopBtnW, h: 36 };
  ctx.fillStyle = '#e8a000';
  ctx.beginPath(); ctx.roundRect(shopBtnX, shopBtnY, shopBtnW, 36, 18); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.min(14, W*0.028)}px sans-serif`;
  ctx.fillText('üõçÔ∏è Shop', shopBtnX + shopBtnW/2, shopBtnY + 23);

  // Purchased items display
  if (purchasedItems.length > 0) {
    ctx.fillStyle = '#4dff88';
    ctx.font = `${Math.min(10, W*0.02)}px sans-serif`;
    const pText = purchasedItems.map(id => shopItems.find(s=>s.id===id)?.icon || '').join(' ');
    ctx.fillText(`Ready: ${pText}`, W/2, shopBtnY + 50);
  }

  const afterShopY = shopBtnY + (purchasedItems.length > 0 ? 66 : 52);

  // Missions
  ctx.fillStyle = '#ff9e4d';
  ctx.font = `bold ${Math.min(13, W*0.026)}px sans-serif`;
  ctx.fillText('üéØ Missions', W/2, afterShopY);
  
  missions.forEach((m, i) => {
    const my = afterShopY + 18 + i * 18;
    ctx.fillStyle = m.completed ? '#4dff88' : '#ccc';
    ctx.font = `${Math.min(11, W*0.022)}px sans-serif`;
    const check = m.completed ? '‚úÖ' : '‚¨ú';
    ctx.fillText(`${check} ${m.desc} (+25ü™ô)`, W/2, my);
  });

  const afterMissionsY = afterShopY + 18 + missions.length * 18 + 20;

  // Leaderboard
  ctx.fillStyle = '#ffd700';
  ctx.font = `bold ${Math.min(14, W*0.028)}px sans-serif`;
  ctx.fillText('üèÜ Leaderboards üèÜ', W/2, afterMissionsY);
  const scoresLbY = afterMissionsY + 16;
  
  // LB tabs
  const lbTabs = [...DIFFICULTY_ORDER];
  const lbTabW = Math.min(50, (W - 20) / lbTabs.length - 2);
  const lbTabStartX = (W - lbTabs.length * (lbTabW + 2)) / 2;
  _lbTabBtns = [];
  lbTabs.forEach((key, idx) => {
    const tx = lbTabStartX + idx * (lbTabW + 2);
    const ty = scoresLbY;
    _lbTabBtns.push({ x: tx, y: ty, w: lbTabW, h: 22, key });
    ctx.fillStyle = key === selectedDifficultyForLB ? '#ffd700' : '#444';
    ctx.beginPath(); ctx.roundRect(tx, ty, lbTabW, 22, 6); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.min(9, lbTabW*0.22)}px sans-serif`;
    const label = key === 'endless' ? '‚ôæÔ∏è' : (DIFFICULTIES[key]?.emoji || key);
    ctx.fillText(label, tx + lbTabW/2, ty + 15);
  });

  const lbScores = leaderboards[selectedDifficultyForLB] || [];
  const lbTopY = scoresLbY + 28;
  if (lbScores.length > 0) {
    ctx.fillStyle = '#ffd700';
    ctx.font = `bold ${Math.min(14,W*0.028)}px sans-serif`;
    const lbLabel = selectedDifficultyForLB === 'endless' ? 'Endless' : DIFFICULTIES[selectedDifficultyForLB].label;
    ctx.fillText(`üèÜ ${lbLabel} Top 10 üèÜ`, W/2, lbTopY);
    const lbSize = Math.min(11, W*0.022);
    ctx.font = `${lbSize}px sans-serif`;
    lbScores.slice(0,10).forEach((s,i) => {
      const medal = i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':'‚≠ê';
      ctx.fillStyle = i<3?'#ffd700':'#ccc';
      ctx.fillText(`${medal} ${s.name} ‚Äî ${s.score}pts`, W/2, lbTopY+14+i*(lbSize+3));
    });
    y = lbTopY + 14 + Math.min(lbScores.length, 10) * (Math.min(11, W*0.022) + 3) + 20;
  } else {
    ctx.fillStyle = '#888';
    ctx.font = `${Math.min(12,W*0.024)}px sans-serif`;
    ctx.fillText('No scores yet ‚Äî be the first! üåü', W/2, lbTopY + 10);
    y = lbTopY + 30;
  }

  // Track max scroll
  titleMaxScroll = Math.max(0, y - H + 20);

  ctx.restore(); // end scroll transform
}

// --- Draw Shop ---
function drawShop() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a0a2e'); grad.addColorStop(1, '#2d1050');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
  ctx.textAlign = 'center';

  ctx.fillStyle = '#ffd700';
  ctx.font = `bold ${Math.min(28, W*0.05)}px sans-serif`;
  ctx.fillText('üõçÔ∏è Shop', W/2, 40);

  ctx.fillStyle = '#ffd700';
  ctx.font = `bold ${Math.min(18, W*0.035)}px sans-serif`;
  ctx.fillText(`ü™ô ${coinBalance}`, W/2, 65);

  _shopItemBtns = [];
  const cardW = Math.min(160, (W - 40) / 2 - 10);
  const cardH = 110;
  const cols = cardW * 2 + 20 <= W - 20 ? 2 : 1;
  const gridW = cols * cardW + (cols - 1) * 10;
  const gridStartX = (W - gridW) / 2;

  shopItems.forEach((item, i) => {
    const col = i % cols;
    const row = Math.floor(i / cols);
    const cx = gridStartX + col * (cardW + 10);
    const cy = 85 + row * (cardH + 10);
    _shopItemBtns.push({ x: cx, y: cy, w: cardW, h: cardH, item });

    const owned = purchasedItems.includes(item.id);
    const canAfford = coinBalance >= item.price;

    ctx.fillStyle = owned ? '#1a3a1a' : canAfford ? '#2a1a4a' : '#1a1a2a';
    ctx.strokeStyle = owned ? '#4dff88' : canAfford ? '#c9a0ff' : '#444';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(cx, cy, cardW, cardH, 12); ctx.fill(); ctx.stroke();

    ctx.font = `${Math.min(28, cardW*0.2)}px sans-serif`;
    ctx.fillStyle = '#fff';
    ctx.fillText(item.icon, cx + cardW/2, cy + 30);

    ctx.font = `bold ${Math.min(13, cardW*0.1)}px sans-serif`;
    ctx.fillStyle = '#fff';
    ctx.fillText(item.name, cx + cardW/2, cy + 50);

    ctx.font = `${Math.min(10, cardW*0.07)}px sans-serif`;
    ctx.fillStyle = '#aaa';
    ctx.fillText(item.desc, cx + cardW/2, cy + 65);

    if (owned) {
      ctx.fillStyle = '#4dff88';
      ctx.font = `bold ${Math.min(13, cardW*0.1)}px sans-serif`;
      ctx.fillText('‚úÖ READY', cx + cardW/2, cy + 90);
    } else {
      ctx.fillStyle = canAfford ? '#ffd700' : '#666';
      ctx.font = `bold ${Math.min(13, cardW*0.1)}px sans-serif`;
      ctx.fillText(`ü™ô ${item.price}`, cx + cardW/2, cy + 90);
    }
  });

  // Back button
  const backW = 100;
  const backY = H - 60;
  _shopBackBtn = { x: (W-backW)/2, y: backY, w: backW, h: 40 };
  ctx.fillStyle = '#444';
  ctx.beginPath(); ctx.roundRect((W-backW)/2, backY, backW, 40, 20); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.min(15, W*0.03)}px sans-serif`;
  ctx.fillText('‚Üê Back', W/2, backY + 26);
}

// --- Draw Win Screen ---
function drawWinScreen() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a0a2e'); grad.addColorStop(1, '#2d1050');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);

  fireworks.forEach(f => {
    ctx.globalAlpha = f.life; ctx.fillStyle = f.color;
    ctx.beginPath(); ctx.arc(f.x, f.y, f.size, 0, Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;

  particles.forEach(p => {
    ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
    if (p.type==='star') drawStar(p.x,p.y,p.size,4,p.color);
    else { ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); }
  });
  ctx.globalAlpha = 1;

  ctx.textAlign = 'center';

  if (showingNameEntry) {
    ctx.fillStyle = '#ffd700';
    ctx.font = `bold ${Math.min(28,W*0.05)}px sans-serif`;
    ctx.fillText('‚≠ê TOP 10 SCORE! ‚≠ê', W/2, H*0.10);

    ctx.fillStyle = '#fff';
    ctx.font = `${Math.min(22,W*0.04)}px sans-serif`;
    ctx.fillText(`${pendingScore} points!`, W/2, H*0.17);

    ctx.fillStyle = '#ff6b9d';
    ctx.font = `bold ${Math.min(22,W*0.04)}px sans-serif`;
    ctx.fillText("What's your name? ü¶Ñ", W/2, H*0.24);

    const boxW = Math.min(280,W*0.7), boxH = 50;
    const boxX = (W-boxW)/2, boxY = H*0.27;
    ctx.shadowColor = '#ff6b9d'; ctx.shadowBlur = 15;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.beginPath(); ctx.roundRect(boxX, boxY, boxW, boxH, 15); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = nameInput ? '#2d1b4e' : '#bbb';
    ctx.font = `bold ${Math.min(26,W*0.045)}px sans-serif`;
    ctx.fillText(nameInput ? nameInput : 'Type your name!', W/2, boxY+boxH/2+9);

    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const btnSize = Math.min(34, Math.floor((W-30)/10));
    const btnPad = 3;
    const rowLen = 10;
    const kbStartY = boxY + boxH + 12;
    const kbW = rowLen*(btnSize+btnPad);
    const kbStartX = (W-kbW)/2;
    const btnColors = ['#ff6b9d','#ff9e4d','#ffd700','#4dff88','#4dc9ff','#c44dff'];

    for (let i = 0; i < letters.length; i++) {
      const row = Math.floor(i/rowLen), col = i%rowLen;
      const bx = kbStartX+col*(btnSize+btnPad), by = kbStartY+row*(btnSize+btnPad);
      ctx.fillStyle = btnColors[i%btnColors.length];
      ctx.beginPath(); ctx.roundRect(bx, by, btnSize, btnSize, 8); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${Math.floor(btnSize*0.5)}px sans-serif`;
      ctx.fillText(letters[i], bx+btnSize/2, by+btnSize*0.65);
    }

    const ctrlY = kbStartY + 3*(btnSize+btnPad)+5;
    const ctrlBtnW = Math.min(100, W*0.25);
    ctx.fillStyle = '#ff4d8b';
    ctx.beginPath(); ctx.roundRect(W/2-ctrlBtnW-10, ctrlY, ctrlBtnW, btnSize+4, 10); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = `bold ${Math.floor(btnSize*0.4)}px sans-serif`;
    ctx.fillText('‚¨Ö Delete', W/2-ctrlBtnW/2-10, ctrlY+btnSize*0.7);
    ctx.fillStyle = '#4dff88';
    ctx.beginPath(); ctx.roundRect(W/2+10, ctrlY, ctrlBtnW, btnSize+4, 10); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.fillText('‚úÖ Done!', W/2+ctrlBtnW/2+10, ctrlY+btnSize*0.7);

    window._nameKB = { letters, btnSize, btnPad, rowLen, kbStartX, kbStartY, ctrlY, ctrlBtnW };
  } else {
    const bounce = Math.abs(Math.sin(winTime*5))*20;
    ctx.font = `${60+Math.sin(winTime*3)*8}px sans-serif`;
    ctx.fillText('ü¶Ñ', W/2, H*0.18-bounce);
    ctx.font = '50px sans-serif';
    ctx.fillText('üåà', W/2, H*0.08);

    const wColors = ['#ff6b9d','#ff9e4d','#ffd700','#4dff88','#4dc9ff','#c44dff'];
    ctx.font = `bold ${Math.min(40,W*0.07)}px sans-serif`;
    const msg = gameMode === 'endless' ? 'GAME OVER!' : 'YOU DID IT!';
    const mw = ctx.measureText(msg);
    const msx = W/2-mw.width/2;
    for (let i = 0; i < msg.length; i++) {
      ctx.fillStyle = wColors[Math.floor((i+winTime*5)%wColors.length)];
      const cw = ctx.measureText(msg[i]).width;
      const yOff = Math.sin(winTime*4+i*0.4)*8;
      ctx.fillText(msg[i], msx+ctx.measureText(msg.substring(0,i)).width+cw/2, H*0.33+yOff);
    }

    ctx.fillStyle = '#fff';
    ctx.font = `${Math.min(22,W*0.04)}px sans-serif`;
    if (gameMode === 'endless') {
      ctx.fillText(`Distance: ${Math.floor(distance)}m | Score: ${score} ‚ú®`, W/2, H*0.41);
    } else {
      ctx.fillText(`You collected ${score} rainbow points! ‚ú®`, W/2, H*0.41);
    }

    // Coins earned
    const bonusCoins = Math.floor(score / 100);
    ctx.fillStyle = '#ffd700';
    ctx.font = `${Math.min(14,W*0.028)}px sans-serif`;
    ctx.fillText(`ü™ô +${coinsCollectedThisRun} collected +${bonusCoins} bonus = ${coinsCollectedThisRun + bonusCoins} coins`, W/2, H*0.46);

    ctx.fillStyle = '#c9a0ff';
    ctx.font = `${Math.min(14,W*0.028)}px sans-serif`;
    ctx.fillText(`Lifetime total: ${cumulativeScore} pts`, W/2, H*0.50);

    const lb = leaderboard;
    const minTop10 = lb.length >= 10 ? lb[lb.length-1].score : 0;
    if (window._nameSubmitted || (score <= minTop10 && lb.length >= 10)) {
      if (!window._nameSubmitted && score <= minTop10) {
        ctx.fillStyle = '#c9a0ff';
        ctx.font = `${Math.min(16,W*0.03)}px sans-serif`;
        ctx.fillText(`Top 10 starts at ${minTop10} ‚Äî keep trying! üåü`, W/2, H*0.54);
      }
    }

    const allScores = lb;
    if (allScores.length > 0) {
      ctx.fillStyle = '#ffd700';
      ctx.font = `bold ${Math.min(16,W*0.032)}px sans-serif`;
      ctx.fillText('üèÜ Top 10 üèÜ', W/2, H*0.60);
      const lbS = Math.min(13,W*0.026);
      ctx.font = `${lbS}px sans-serif`;
      allScores.slice(0,10).forEach((s,i) => {
        const medal = i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':'‚≠ê';
        ctx.fillStyle = i<3?'#ffd700':'#ccc';
        ctx.fillText(`${medal} ${s.name} ‚Äî ${s.score}pts`, W/2, H*0.60+18+i*(lbS+5));
      });
    }

    ctx.font = '26px sans-serif';
    ctx.fillText('üéâ ü¶Ñ üåà ‚≠ê üíñ üéâ', W/2, H*0.90);

    if (winTime > 2) {
      const pulse2 = 0.7+Math.sin(winTime*3)*0.3;
      ctx.globalAlpha = pulse2;
      ctx.fillStyle = '#ffd700';
      ctx.font = `bold ${Math.min(22,W*0.04)}px sans-serif`;
      ctx.fillText('üåü Tap to Play Again! üåü', W/2, H*0.95);
      ctx.globalAlpha = 1;
    }
  }
}

// --- Main Draw ---
function draw() {
  ctx.clearRect(0, 0, W, H);

  if (gameState === 'title') { drawTitle(); return; }
  if (gameState === 'shop') { drawShop(); return; }
  if (gameState === 'win') { drawWinScreen(); return; }

  // Screen shake
  ctx.save();
  if (shakeAmount > 0.5) {
    ctx.translate((Math.random()-0.5)*shakeAmount, (Math.random()-0.5)*shakeAmount);
  }

  drawPlayBackground();

  // Rainbow trail
  const trailColors = ['#ff6b9d','#ff9e4d','#ffd700','#4dff88','#4dc9ff','#c44dff'];
  if (unicorn.trail.length > 1) {
    unicorn.trail.forEach((t, i) => {
      if (i===0) return;
      ctx.globalAlpha = t.life * 0.4;
      ctx.strokeStyle = t.color || trailColors[i%trailColors.length];
      ctx.lineWidth = t.life * 5;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(unicorn.trail[i-1].x, unicorn.trail[i-1].y + (i-1)*2);
      ctx.lineTo(t.x, t.y + i*2);
      ctx.stroke();
    });
    ctx.globalAlpha = 1;
  }

  // Draw items on screen
  const viewRange = 600;

  // Ghost unicorn (race mode only)
  if (gameMode === 'race' && ghostData && ghostData.positions && ghostVisible) {
    const checkpoint = Math.floor(distance / 100);
    if (checkpoint >= 0 && checkpoint < ghostData.positions.length) {
      const ghostX = ghostData.positions[checkpoint] * W;
      const ghostY = H * 0.72;
      drawGhostUnicorn(ghostX, ghostY);
    }
  }

  // Rainbows
  trackRainbows.forEach((rb, i) => {
    if (collectedSet.has(i)) return;
    const relY = (rb.y - distance) / viewRange;
    if (relY < -0.05 || relY > 1.05) return;
    const screenY = H * (1 - relY * 0.85 - 0.08);
    let screenX = rb.x * W;
    if (DIFFICULTIES[currentDifficulty].sway) {
      screenX += Math.sin(Date.now()/500 + rb.swayOffset) * 40;
    }
    const bob = Math.sin(Date.now()/400 + i) * 5;
    drawRainbow(screenX, screenY + bob, rb.type);
  });

  // Coins
  trackCoins.forEach((c, i) => {
    if (collectedCoins.has(i)) return;
    const relY = (c.y - distance) / viewRange;
    if (relY < -0.05 || relY > 1.05) return;
    const screenY = H * (1 - relY * 0.85 - 0.08);
    const screenX = c.x * W;
    const bob = Math.sin(Date.now()/350 + i*2) * 4;
    drawCoin(screenX, screenY + bob);
  });

  // Obstacles
  trackObstacles.forEach((obs, i) => {
    if (collectedObstacles.has(i)) return;
    const relY = (obs.y - distance) / viewRange;
    if (relY < -0.05 || relY > 1.05) return;
    const screenY = H * (1 - relY * 0.85 - 0.08);
    const screenX = obs.x * W;
    drawObstacle(screenX, screenY, obs);
  });

  // Power-ups
  trackPowerUps.forEach((pu, i) => {
    if (collectedPowerUps.has(i)) return;
    const relY = (pu.y - distance) / viewRange;
    if (relY < -0.05 || relY > 1.05) return;
    const screenY = H * (1 - relY * 0.85 - 0.08);
    const screenX = pu.x * W;
    const bob = Math.sin(Date.now()/300 + i*2) * 6;
    drawPowerUpItem(screenX, screenY + bob, pu);
  });

  // Finish rainbow (race mode)
  if (gameMode === 'race') {
    const finishRelY = (currentTrackLength - distance) / viewRange;
    const finishBaseY = H * 0.72 - finishRelY * H * 0.85;
    if (finishBaseY > -W*0.5 && finishBaseY < H + 50) {
      drawFinishRainbow(finishBaseY);
    }
  }

  // Draw unicorn
  const ux = unicorn.x * W;
  const uy = H * 0.72;
  drawUnicorn(ux, uy, unicorn.sparkle);

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
    if (p.type==='star') drawStar(p.x,p.y,p.size,4,p.color);
    else { ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); }
  });
  ctx.globalAlpha = 1;

  ctx.restore(); // end screen shake

  drawHUD();
}

// --- Loop ---
function gameLoop(timestamp) {
  const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
  lastTime = timestamp;
  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

// --- Start ---
initBGClouds();
generateTrack();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>